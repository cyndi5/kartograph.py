 s > b FidúÙ¯∑ ,b + [úÙßΩúÙ§Ê > b,1 |úÙßΩúÙ§Á > b,1 ]  mod q They are valid challenge ciphertext parts in Game 2. Therefore, in this case B simulates Game 2 for A. On the other hand, if B gets samples from O$ , (cb,0, cb,1) constructed above will be random, which is the case of Game 3, and B simulates Game 3. |Pr[S2] úÙ¯≤ Pr[S3]| úÙ˘§ LWE follows. Lemma 4.5. |Pr[S3] úÙ¯≤ Pr[S4]| = 0. Proof. Note for generating (c1úÙ¯≤b,0, c1úÙ¯≤b,1) of the challenge ciphertext, Encrypt and Sim.Encrypt behave the same. (cb,0, cb,1) is a random string in both games. So adversaryúÙÚ˘s advantages in Game 4 and Game 3 are the same. Lemma 4.6. Game 5 and Game 4 are statistically indistinguishable, so |Pr[S4] úÙ¯≤ Pr[S5]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Proof. The proof is essentially the same as the proof for Lemma 4.2. We omit the details. Lemma 4.7. If the PRF PRF is (t, PRF)-secure, then |Pr[S5] úÙ¯≤ Pr[S6]| úÙ˘§ 2PRF. 25 Proof. We recall the difference between Game 6 and Game 5. let b = PRF(K, idúÙ¯∑ ) for the challenge identity idúÙ¯∑ . In Game 5, the ciphertext component (cb,0, cb,1) is uniformly random and (c1úÙ¯≤b,0, c1úÙ¯≤b,1) is computed by Encrypt. In Game 6, the ciphertext component (cb,0, cb,1) is computed by Encrypt and (c1úÙ¯≤b,0, c1úÙ¯≤b,1) is uniformly random. To prove the indistinguishably between Game 6 and Game 5, three additional security games are added. Firstly we define Game 5.1 which is same as Game 5 except that it samples b $úÙˆúÙ¯≤ {0, 1} to select matrix Ab for generating private keys and challenge ciphertext instead of using PRF to compute it. Also, if same identity is queried multiple times, the same bit b will be used (For simulation, we simply let the simulator keep a state remembering the bit for each identity.). Obviously, a distinguisher between Game 5 and Game 5.1 leads to a attacker for PRF. So |Pr[S5] úÙ¯≤ Pr[S5.1]| úÙ˘§ PRF. Secondly, we define Game 5.2 which is the same as Game 5.1 except for randomly sampled bit b for idúÙ¯∑ , it runs Encrypt to produce (cb,0, cb,1) and samples (c1úÙ¯≤b,0, c1úÙ¯≤b,1) uniformly random from Zq Å◊ Z 2m q . While here b is uniformly random, we must have |Pr[S5.1] úÙ¯≤ Pr[S5.2]| = 0. Finally, as Game 6 is the same as Game 5.2 except the bit value b is computed via PRF in key generation query phase and challenge phase, so we have |Pr[S5.2] úÙ¯≤ Pr[S6]| úÙ˘§ PRF. |Pr[S5] úÙ¯≤ Pr[S6]| úÙ˘§ 2PRF follows. Lemma 4.8. Game 7 and Game 6 are statistically indistinguishable, so |Pr[S6] úÙ¯≤ Pr[S7]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Proof. The proof is essentially the same as the proof for Lemma 4.2. We omit the details. Lemma 4.9. Game 8 and Game 7 are statistically indistinguishable, so |Pr[S7] úÙ¯≤ Pr[S8]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Proof. The proof is essentially the same as the proof for Lemma 4.3. We omit the details. Lemma 4.10. If (t, LWE)-LWEn,q,úÙß« assumption holds where úÙß« stands for the distribution DZ,úÙß√LWE reduced modulo q, then |Pr[S8] úÙ¯≤ Pr[S9]| úÙ˘§ LWE. Proof. The proof is essentially the same as the proof for Lemma 4.4. We omit the details. Now we prove the Theorem 4.1 by the established lemmas. Proof. Based on the lemmas that show the difference between the sequence of games, we have  = |Pr[S0] úÙ¯≤ 1/2| úÙ˘§ 2(PRF + LWE) + negl(úÙßª) for some negligibly small statistical error negl(úÙßª). The running time of B is dominated by answering qid private key generation queries from A. For answering one such query, B needs to apply the key-homomorphic algorithm on the circuit of PRF. This requires time TE. Besides that, B needs to run SampleRight to sample Gaussian vectors for constructing the private keys, which requires at most time TS. Therefore, for one query, B roughly runs O(TS + TE) time. For all qid queries and constructing the challenge ciphertext, the total time is bounded by O (qid Å∑ (TS + TE)). So if an adversary A has running time t, max(tLWE, tPRF) úÙ˘§ t + O(qid Å∑ (TS + TE)). 4.5 Adaptively CCA-Secure IBE and CCA-Secure PKE Boneh at al. [17] showed a ` + 1-depth CPA-secure Hierarchical IBE (HIBE) scheme (` úÙ˘• 0) can be tightly transferred into an `-depth CCA-secure HIBE scheme with small additional overhead (known as the BCHK transformation). In particularly, a 1-depth HIBE scheme is an IBE scheme and a 0-depth HIBE scheme is a public-key encryption scheme PKE. Generally, in HIBE, identities are arranged in a directed tree. A user with identity of a father node can issue private keys for the users with identities of children nodes. This process is called delegation. Ideally, we would like to have HIBE schemes supporting identity trees with polynomial depth. 26 Unfortunately, directly applying our technique will result in an HIBE scheme with only log-depth identity tree. On the other hand, our technique particularly works for 2-depth HIBE scheme. So by applying the BCHK transformation, we obtain a IND-ID-CCA2 secure IBE scheme from the 2-depth IND-ID-CPA HIBE scheme and a IND-CCA2 secure PKE scheme from our IND-ID-CPA secure IBE scheme9 . 5 Conclusions In this paper, we propose a short adaptively secure lattice signature scheme and a úÙÚ¸compactúÙÚ˝ adaptively secure IBE scheme in the standard model. Our constructions make use of PRFs in a novel way by combining several recent techniques in the area of lattice-based cryptography. The security of our signature and IBE scheme is tightly related to the conservative lattice assumptions SIS and LWE, respectively, and the security of an instantiated PRF, with a constant loss factor. By instantiating the existing efficient PRFs from lattice and number-theoretic assumptions which can be implemented by shallow circuits, we obtain the first úÙÚ¸almostúÙÚ˝ tightly secure lattice-based short signature/IBE scheme whose security is based on LWE assumption with super-polynomial modulus, and an adaptively secure IBE scheme with the tightest security reduction so far, i.e. with only O(log2 úÙßª) factor of security loss for the security parameter úÙßª, based on a novel combination of lattice and number-theoretic assumptions. The problem of constructing a tightly and adaptively secure IBE scheme from standard assumptions (in the sense that the security loss of reduction is a constant) remains open. Our work suggests that constructing tightly secure PRFs, which is another important open problem left by [31, 47], would solve it. We leave as a fascinating open problem the question of employing similar (or different) techniques to construct compact and (almost) tightly secure signature and encryption schemes with increased expressiveness, such as hierarchical and attribute-based encryption scheme, or homomorphic signatures. Another interesting open question is to construct a PRF from LWE assumption with polynomial modulus. Acknowledgement We would like to thank Jacob Alperin-Sheriff for useful comments. References [1] Masayuki Abe, Bernardo David, Markulf Kohlweiss, Ryo Nishimaki, and Miyako Ohkubo. Public-key cryptography úÙÚÛ pkc 2013: 16th international conference on practice and theory in public-key cryptography, nara, japan, february 26 úÙÚÛ march 1, 2013. proceedings. chapter Tagged One-Time Signatures: Tight Security and Optimal Tag Size, pages 312úÙÚÛ331. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. [2] Shweta Agrawal, Dan Boneh, and Xavier Boyen. Efficient lattice (h)ibe in the standard model. In Henri Gilbert, editor, Advances in Cryptology - EUROCRYPT 2010, volume 6110 of Lecture Notes in Computer Science, pages 553úÙÚÛ572. Springer Berlin Heidelberg, 2010. [3] MiklÅ¥os Ajtai. Generating hard instances of lattice problems (extended abstract). In Proceedings of the Twenty-eighth Annual ACM Symposium on Theory of Computing, STOC úÙÚ˘96, pages 99úÙÚÛ108, New York, NY, USA, 1996. ACM. 9This transformation does not require us to add new computational assumptions. The SIS assumption, which is weaker than the LWE assumption, is enough. 27 [4] Jacob Alperin-Sheriff. Short signatures with short public keys from homomorphic trapdoor functions. In Jonathan Katz, editor, Public-Key Cryptography úÙÚÛ PKC 2015, volume 9020 of Lecture Notes in Computer Science, pages 236úÙÚÛ255. Springer Berlin Heidelberg, 2015. [5] Daniel Apon, Xiong Fan, and Feng-Hao Liu. Fully-secure lattice-based IBE as compact as PKE. Cryptology ePrint Archive, Report 2016/125, 2016. http://eprint.iacr.org/. [6] Nuttapong Attrapadung, Goichiro Hanaoka, and Shota Yamada. A framework for identitybased encryption with almost tight security. In Tetsu Iwata and JungHee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015, volume 9452 of Lecture Notes in Computer Science, pages 521úÙÚÛ549. Springer Berlin Heidelberg, 2015. [7] Shi Bai, Adeline Langlois, Tancr`ede Lepoint, Damien StehlÅ¥e, and Ron Steinfeld. Improved security proofs in lattice-based cryptography: using the rÅ¥enyi divergence rather than the statistical distance. In Advances in CryptologyúÙÚÛASIACRYPT 2015, pages 3úÙÚÛ24. Springer, 2015. [8] Abhishek Banerjee and Chris Peikert. New and improved key-homomorphic pseudorandom functions. In JuanA. Garay and Rosario Gennaro, editors, Advances in Cryptology úÙÚÛ CRYPTO 2014, volume 8616 of Lecture Notes in Computer Science, pages 353úÙÚÛ370. Springer Berlin Heidelberg, 2014. [9] Abhishek Banerjee, Chris Peikert, and Alon Rosen. Pseudorandom functions and lattices. In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology úÙÚÛ EUROCRYPT 2012, volume 7237 of Lecture Notes in Computer Science, pages 719úÙÚÛ737. Springer Berlin Heidelberg, 2012. [10] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proceedings of the 1st ACM Conference on Computer and Communications Security, CCS úÙÚ˘93, pages 62úÙÚÛ73, New York, NY, USA, 1993. ACM. [11] Olivier Blazy, SaqibA. Kakvi, Eike Kiltz, and Jiaxin Pan. Tightly-secure signatures from chameleon hash functions. In Jonathan Katz, editor, Public-Key Cryptography úÙÚÛ PKC 2015, volume 9020 of Lecture Notes in Computer Science, pages 256úÙÚÛ279. Springer Berlin Heidelberg, 2015. [12] Olivier Blazy, Eike Kiltz, and Jiaxin Pan. (hierarchical) identity-based encryption from affine message authentication. In JuanA. Garay and Rosario Gennaro, editors, Advances in Cryptology úÙÚÛ CRYPTO 2014, volume 8616 of Lecture Notes in Computer Science, pages 408úÙÚÛ425. Springer Berlin Heidelberg, 2014. [13] Florian BÅ®ohl, Dennis Hofheinz, Tibor Jager, Jessica Koch, Jae Hong Seo, and Christoph Striecks. Advances in Cryptology úÙÚÛ EUROCRYPT 2013: 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, chapter Practical Signatures from Standard Assumptions, pages 461úÙÚÛ485. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. [14] Dan Boneh and Xavier Boyen. Efficient selective-id secure identity-based encryption without random oracles. In Christian Cachin and JanL. Camenisch, editors, Advances in Cryptology - EUROCRYPT 2004, volume 3027 of Lecture Notes in Computer Science, pages 223úÙÚÛ238. Springer Berlin Heidelberg, 2004. [15] Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In Matt Franklin, editor, Advances in Cryptology - CRYPTO 2004, volume 3152 of Lecture Notes in Computer Science, pages 443úÙÚÛ459. Springer Berlin Heidelberg, 2004. 28 [16] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and JanL. Camenisch, editors, Advances in Cryptology - EUROCRYPT 2004, volume 3027 of Lecture Notes in Computer Science, pages 56úÙÚÛ73. Springer Berlin Heidelberg, 2004. [17] Dan Boneh, Ran Canetti, Shai Halevi, and Jonathan Katz. Chosen-ciphertext security from identity-based encryption. SIAM J. Comput., 36(5):1301úÙÚÛ1328, December 2006. [18] Dan Boneh and Matt Franklin. Identity-based encryption from the weil pairing. In Joe Kilian, editor, Advances in Cryptology CRYPTO 2001, volume 2139 of Lecture Notes in Computer Science, pages 213úÙÚÛ229. Springer Berlin Heidelberg, 2001. [19] Dan Boneh, Craig Gentry, Sergey Gorbunov, Shai Halevi, Valeria Nikolaenko, Gil Segev, Vinod Vaikuntanathan, and Dhinakaran Vinayagamurthy. Fully key-homomorphic encryption, arithmetic circuit abe and compact garbled circuits. In PhongQ. Nguyen and Elisabeth Oswald, editors, Advances in Cryptology - EUROCRYPT 2014, volume 8441 of Lecture Notes in Computer Science, pages 533úÙÚÛ556. Springer Berlin Heidelberg, 2014. [20] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the weil pairing. Journal of Cryptology, 17(4):297úÙÚÛ319, 2004. [21] Xavier Boyen. Lattice mixing and vanishing trapdoors: A framework for fully secure short signatures and more. In PhongQ. Nguyen and David Pointcheval, editors, Public Key Cryptography - PKC 2010, volume 6056 of Lecture Notes in Computer Science, pages 499úÙÚÛ517. Springer Berlin Heidelberg, 2010. [22] Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien StehlÅ¥e. Classical hardness of learning with errors. In Proceedings of the Forty-fifth Annual ACM Symposium on Theory of Computing, STOC úÙÚ˘13, pages 575úÙÚÛ584, New York, NY, USA, 2013. ACM. [23] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) LWE. In Proceedings of the 2011 IEEE 52nd Annual Symposium on Foundations of Computer Science, FOCS úÙÚ˘11, pages 97úÙÚÛ106, Washington, DC, USA, 2011. IEEE Computer Society. [24] Zvika Brakerski and Vinod Vaikuntanathan. Lattice-based FHE as secure as PKE. In Proceedings of the 5th conference on Innovations in theoretical computer science, pages 1úÙÚÛ12. ACM, 2014. [25] Zvika Brakerski and Vinod Vaikuntanathan. Circuit-abe from lwe: Unbounded attributes and semi-adaptive security. Cryptology ePrint Archive, Report 2016/118, 2016. http: //eprint.iacr.org/. [26] Jan Camenisch and Anna Lysyanskaya. Advances in Cryptology úÙÚÛ CRYPTO 2004: 24th Annual International Cryptology Conference, Santa Barbara, California, USA, August 15-19, 2004. Proceedings, chapter Signature Schemes and Anonymous Credentials from Bilinear Maps, pages 56úÙÚÛ72. Springer Berlin Heidelberg, Berlin, Heidelberg, 2004. [27] Ran Canetti, Shai Halevi, and Jonathan Katz. A forward-secure public-key encryption scheme. In Eli Biham, editor, Advances in Cryptology - EUROCRYPT 2003, volume 2656 of Lecture Notes in Computer Science, pages 255úÙÚÛ271. Springer Berlin Heidelberg, 2003. [28] David Cash, Dennis Hofheinz, Eike Kiltz, and Chris Peikert. Bonsai trees, or how to delegate a lattice basis. Journal of Cryptology, 25(4):601úÙÚÛ639, 2012. 29 [29] Jie Chen and Hoeteck Wee. Fully, (almost) tightly secure ibe and dual system groups. In Ran Canetti and JuanA. Garay, editors, Advances in Cryptology - CRYPTO 2013, volume 8043 of Lecture Notes in Computer Science, pages 435úÙÚÛ460. Springer Berlin Heidelberg, 2013. [30] Ronald Cramer and Victor Shoup. Signature schemes based on the strong rsa assumption. ACM Trans. Inf. Syst. Secur., 3(3):161úÙÚÛ185, August 2000. [31] Nico DÅ®ottling and Dominique SchrÅ®oder. Efficient pseudorandom functions via on-the-fly adaptation. In Advances in CryptologyúÙÚÛCRYPTO 2015, pages 329úÙÚÛ350. Springer, 2015. [32] LÅ¥eo Ducas and Daniele Micciancio. Advances in Cryptology úÙÚÛ CRYPTO 2014: 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part I, chapter Improved Short Lattice Signatures in the Standard Model, pages 335úÙÚÛ352. Springer Berlin Heidelberg, Berlin, Heidelberg, 2014. [33] Marc Fischlin. The Cramer-Shoup Strong-RSA Signature Scheme Revisited, volume 2567 of Lecture Notes in Computer Science, pages 116úÙÚÛ129. Springer Berlin Heidelberg, 2003. [34] Rosario Gennaro, Shai Halevi, and Tal Rabin. Advances in Cryptology úÙÚÙ EUROCRYPT úÙÚ˘99: International Conference on the Theory and Application of Cryptographic Techniques Prague, Czech Republic, May 2úÙÚÛ6, 1999 Proceedings, chapter Secure Hash-and-Sign Signatures Without the Random Oracle, pages 123úÙÚÛ139. Springer Berlin Heidelberg, Berlin, Heidelberg, 1999. [35] Craig Gentry. Practical identity-based encryption without random oracles. In Serge Vaudenay, editor, Advances in Cryptology - EUROCRYPT 2006, volume 4004 of Lecture Notes in Computer Science, pages 445úÙÚÛ464. Springer Berlin Heidelberg, 2006. [36] Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. Trapdoors for hard lattices and new cryptographic constructions. In Proceedings of the 40th annual ACM symposium on Theory of computing, STOC úÙÚ˘08, pages 197úÙÚÛ206, New York, NY, USA, 2008. ACM. [37] Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptotically-faster, attribute-based. In Ran Canetti and JuanA. Garay, editors, Advances in Cryptology - CRYPTO 2013, volume 8042 of Lecture Notes in Computer Science, pages 75úÙÚÛ92. Springer Berlin Heidelberg, 2013. [38] Eu-Jin Goh and Stanis law Jarecki. Advances in Cryptology úÙÚÙ EUROCRYPT 2003: International Conference on the Theory and Applications of Cryptographic Techniques, Warsaw, Poland, May 4úÙÚÛ8, 2003 Proceedings, chapter A Signature Scheme as Secure as the DiffieHellman Problem, pages 401úÙÚÛ415. Springer Berlin Heidelberg, Berlin, Heidelberg, 2003. [39] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. J. ACM, 33(4):792úÙÚÛ807, August 1986. [40] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Attribute-based encryption for circuits. In Proceedings of the 45th annual ACM symposium on Symposium on theory of computing, STOC úÙÚ˘13, pages 545úÙÚÛ554, New York, NY, USA, 2013. ACM. [41] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Predicate encryption for circuits from lwe. In Rosario Gennaro and Matthew Robshaw, editors, Advances in Cryptology úÙÚÛ CRYPTO 2015, volume 9216 of Lecture Notes in Computer Science, pages 503úÙÚÛ523. Springer Berlin Heidelberg, 2015. 30 [42] Sergey Gorbunov and Dhinakaran Vinayagamurthy. Riding on asymmetry: Efficient abe for branching programs. In International Conference on the Theory and Application of Cryptology and Information Security, pages 550úÙÚÛ574. Springer, 2015. [43] Dennis Hofheinz and Tibor Jager. Advances in Cryptology úÙÚÛ CRYPTO 2012: 32nd Annual Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings, chapter Tightly Secure Signatures and Public-Key Encryption, pages 590úÙÚÛ607. Springer Berlin Heidelberg, Berlin, Heidelberg, 2012. [44] Dennis Hofheinz, Jessica Koch, and Christoph Striecks. Identity-based encryption with (almost) tight security in the multi-instance, multi-ciphertext setting. In Jonathan Katz, editor, Public-Key Cryptography úÙÚÛ PKC 2015, volume 9020 of Lecture Notes in Computer Science, pages 799úÙÚÛ822. Springer Berlin Heidelberg, 2015. [45] Susan Hohenberger and Brent Waters. Advances in Cryptology - EUROCRYPT 2009: 28th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cologne, Germany, April 26-30, 2009. Proceedings, chapter Realizing Hash-andSign Signatures under Standard Assumptions, pages 333úÙÚÛ350. Springer Berlin Heidelberg, Berlin, Heidelberg, 2009. [46] Susan Hohenberger and Brent Waters. Short and stateless signatures from the rsa assumption. In Shai Halevi, editor, Advances in Cryptology - CRYPTO 2009, volume 5677 of Lecture Notes in Computer Science, pages 654úÙÚÛ670. Springer Berlin Heidelberg, 2009. [47] Tibor Jager. Tightly-secure pseudorandom functions via work factor partitioning. Cryptology ePrint Archive, Report 2016/121, 2016. http://eprint.iacr.org/. [48] Jonathan Katz and Nan Wang. Efficiency improvements for signature schemes with tight security reductions. In Proceedings of the 10th ACM Conference on Computer and Communications Security, CCS úÙÚ˘03, pages 155úÙÚÛ164, New York, NY, USA, 2003. ACM. [49] Allison Lewko and Brent Waters. New proof methods for attribute-based encryption: Achieving full security through selective techniques. In Reihaneh Safavi-Naini and Ran Canetti, editors, Advances in Cryptology - CRYPTO 2012, volume 7417 of Lecture Notes in Computer Science, pages 180úÙÚÛ198. Springer Berlin Heidelberg, 2012. [50] Vadim Lyubashevsky. Lattice signatures without trapdoors. In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology úÙÚÛ EUROCRYPT 2012, volume 7237 of Lecture Notes in Computer Science, pages 738úÙÚÛ755. Springer Berlin Heidelberg, 2012. [51] Daniele Micciancio and Chris Peikert. Trapdoors for lattices: Simpler, tighter, faster, smaller. In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology ? EUROCRYPT 2012, volume 7237 of Lecture Notes in Computer Science, pages 700úÙÚÛ718. Springer Berlin Heidelberg, 2012. [52] Daniele Micciancio and Oded Regev. Worst-case to average-case reductions based on gaussian measures. SIAM J. Comput., 37(1):267úÙÚÛ302, April 2007. [53] Moni Naor and Omer Reingold. Number-theoretic constructions of efficient pseudo-random functions. J. ACM, 51(2):231úÙÚÛ262, March 2004. [54] Chris Peikert. Public-key cryptosystems from the worst-case shortest vector problem: extended abstract. In Proceedings of the 41st annual ACM symposium on Theory of computing, STOC úÙÚ˘09, pages 333úÙÚÛ342, New York, NY, USA, 2009. ACM. 31 [55] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In Proceedings of the thirty-seventh annual ACM symposium on Theory of computing, STOC úÙÚ˘05, pages 84úÙÚÛ93, New York, NY, USA, 2005. ACM. [56] Brent Waters. Efficient identity-based encryption without random oracles. In Ronald Cramer, editor, Advances in Cryptology - EUROCRYPT 2005, volume 3494 of Lecture Notes in Computer Science, pages 114úÙÚÛ127. Springer Berlin Heidelberg, 2005. [57] Brent Waters. Dual system encryption: Realizing fully secure ibe and hibe under simple assumptions. In Shai Halevi, editor, Advances in Cryptology - CRYPTO 2009, volume 5677 of Lecture Notes in Computer Science, pages 619úÙÚÛ636. Springer Berlin Heidelberg, 2009. 32










 s >[A|AR] + [x > + y >|(x > úÙ¯≤ y >)R + z >]  mod q =  [s >A + x >|(s >A + x >)R] + [y >| úÙ¯≤ y >R + z >]  mod q =  [v >|v >R] + [y >| úÙ¯≤ y >R + z >]  mod q =  s > b u + úÙßΩb,0 + MsgúÙ¯∑ bq/2c  mod q and c > b,1 =  s >w + x + MsgúÙ¯∑ bq/2c  mod q =  mod q 3. B sets (c1úÙ¯≤b,0, c1úÙ¯≤b,1) the same as Game 2. Phase 2. B replies the private key queries as in Game 2. Guess. Finally, A outputs whether it is interacting with Game 2 or Game 3. If A says Game 2, B decides its LWE challenge is from Os. Otherwise, B decides the LWE challenge is from O$ . If B gets the LWE challenge from the oracle Os, there exists a secret vector s úÙ¯® Z n q , a noise scalar x with distribution DZ,úÙß√LWE , a noise vector x úÙ¯® Z m with distribution DZm,úÙß√LWE such that v > = s >A + x > and v = s >w + x. Rewrite the ciphertext we have cb,0 = (v + MsgúÙ¯∑ bq/2c) mod q =  s > 0 A|AR + [(x + y) >|R(x úÙ¯≤ y) > + z >]  mod q By the Lemma 2.1 (the generalised left-over hash lemma), with R appearing in the challenge ciphertext, the public matrices A0, A1, {Bi}iúÙ¯®[k] , C0, C1 still have distribution which is statistically close to the uniform distribution on Z nÅ◊m q . Now we use the idea of smoothing parameter and continuous Gaussian approximation to show that the noise terms (x + y, R>(x úÙ¯≤ y) + z) have proper distribution. 8 In particularly, we show x + y and R>(x úÙ¯≤ y) + z have proper distributions individually and are statistically independent. Firstly, since R has independent columns and z has independent coordinates and R, z would not appear in other places, vector R>(xúÙ¯≤y)+z has independent coordinates. Secondly, xúÙ¯≤y is discrete Gaussian with Gaussian parameter úÙß√LWE greater than the smoothing parameter úÙß∑úÙßµ(Z m), so R>(x úÙ¯≤ y) is a mixture of discrete Gaussians that closely approximates a (mixture of) continuous Gaussians, but only on a úÙÚ˝large scaleúÙÚ˝ greater than kRk Å∑ úÙß∑úÙßµ(Z m). The term z is used to smooth out all visible discretisation introduced by R and make R>(x úÙ¯≤ y) + z closely approximate a continuous Gaussian that has zero-correlation and fixed standard deviation. So by the construction of Sim.Encrypt and Lemma 2.5, R>(x úÙ¯≤ y) + z has distribution which is statistically close to DZm,úÙß√ as required. By the same reason, x + y has discrete Gaussian distribution DZm, úÙ¯∫ 2úÙß√LWE that closely approximates the continuous Gaussian with standard deviation úÙ¯∫ 2úÙß√LWE. Since each of x + y and R>(x úÙ¯≤ y) + z closely approximates a multivariate continuous Gaussian as seen above, for which the covariance Cov(x + y, R>(x úÙ¯≤ y) + z) = 0 making (the continuous approximations of) x + y and R>(x úÙ¯≤ y) + z statistically independent. Summing up, cb,1 output by Encrypt has distribution that is statistically close to the distribution of cb,1 output by Sim.Encrypt. Therefore Game 1 and Game 2 are statistically indistinguishable and the lemma follows. Lemma 4.4. If (t, LWE)-LWEn,q,úÙß« assumption holds where úÙß« stands for the distribution DZ,úÙß√LWE reduced modulo q, then |Pr[S2] úÙ¯≤ Pr[S3]| úÙ˘§ LWE. Proof. We show a simulation algorithm B that uses its LWE challenge to simulate either Game 2 or Game 3 for an adversary A. At the beginning, B receives its LWE challenge (W, v) úÙ¯® Z nÅ◊m q Å◊ Z m q and (w, v) úÙ¯® Z n q Å◊ Zq which is either from O$ or Os. Setup. B prepares the public parameters for A as follows: 1. Set A úÙˆ W and u úÙˆ v. We note A, u have uniform distribution. 2. Set other public parameters as Game 2. Phase 1. B answers private key queries like Game 2. Challenge. B prepares the challenge ciphertext of identity idúÙ¯∑ as follows. 8Notice that the simulator knows R and adversary does not know R, x úÙ¯≤ y, and z individually. 24 1. Let b = PRF(K, idúÙ¯∑ ). B sets FidúÙ¯∑ ,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,idúÙ¯∑ = A | A(RA1úÙ¯≤b úÙ¯≤ RCPRF,idúÙ¯∑ ) + (1 úÙ¯≤ 2b)G 2. Let R = RA0 úÙ¯≤ RCPRF,idúÙ¯∑ . B samples y úÙˆ DZm,úÙß√LWE . It also samples z úÙ¯® Z m as in Sim.Encrypt by its knowledge of R. Then to construct (cb,0, cb,1), it sets úÛ‚— úÛ‚“ úÛ‚” cb,0 = (v + MsgúÙ¯∑ bq/2c) mod q c > b,1 = [v >|v >R] + [y >| úÙ¯≤ y >R + z >] 

 s > b FidúÙ¯∑ ,b + [úÙßΩúÙ§Ê > b,1 | úÙßΩúÙ§Á > b,1 ]  mod q = s > 0 A|A(RAb úÙ¯≤ RCPRF,idúÙ¯∑ ) +[(x + y) > | R(x úÙ¯≤ y) > + z >]  mod q =  s > 1úÙ¯≤bFidúÙ¯∑ ,1úÙ¯≤b + [úÙßΩúÙ§Ê > 1úÙ¯≤b,1 | úÙßΩúÙ§Á > 1úÙ¯≤b,1 ]  mod q Now we define a series of games and prove that the neighboring games are either statistically indistinguishable, or computationally indistinguishable. Game 0 This is the real IND-ID-CPA game from the definition. All the algorithms are the same as the real scheme. Game 1 This game is the same as Game 0 except it runs Sim.Setup and Sim.KeyGen instead of Setup and KeyGen. Game 2 This game is the same as Game 1 except that the challenge ciphertext is generated by Sim.Encrypt instead of Encrypt. Game 3 This game is the same as Game 2 except that during preparation of the challenge ciphertext for identity idúÙ¯∑ , it samples (cb,0, cb,1) uniformly random from Zq Å◊ Z 2m q for b = PRF(K, idúÙ¯∑ ). Another part of the challenge ciphertext (c1úÙ¯≤b,0, c1úÙ¯≤b,1) is computed by Sim.Encrypt as in Game 2. Game 4 This game is the same as Game 3 except for b = PRF(K, idúÙ¯∑ ) it runs real encryption algorithm Encrypt to generate (c1úÙ¯≤b,0, c1úÙ¯≤b,1) of the challenge ciphertext instead of using Sim.Encrypt. Game 5 This game is the same as Game 4 except it runs Setup and KeyGen to generate Pub and private identity keys. Game 6 This game is the same as Game 5 except that for b = PRF(K, idúÙ¯∑ ), the challenge ciphertext part (cb,0, cb,1) is generated by Encrypt instead of choosing it randomly, and (c1úÙ¯≤b,0, c1úÙ¯≤b,1) is chosen randomly. 7 In section 4.3, the úÙß√ is set large enough such that úÙß√1,i can be larger than kRk Å∑ úÙß∑úÙßµ(Z m). 22 Game 7 This game is the same as Game 6 except that it runs Sim.Setup and Sim.KeyGen to generate Pub and private identity keys. Game 8 This game is the same as Game 7 except that for the bit value b = PRF(K, idúÙ¯∑ ), it computes the challenge ciphertext (cb,0, cb,1) by Sim.Encrypt. Game 9 This game is the same as Game 8 except that the whole challenge ciphertext is sampled uniformly at random from the ciphertext space. Therefore, in Game 5 the adversary has no advantage in wining the game. In Game i, we let Si be the event that úÙß≥ 0 = úÙß≥ at the end of the game. The adversaryúÙÚ˘s advantage in Game i is |Pr[Si ]úÙ¯≤ 1 2 |. We prove the following lemmas to prove the Theorem 4.1. Lemma 4.2. Game 1 and Game 0 are statistically indistinguishable, so |Pr[S0] úÙ¯≤ Pr[S1]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Proof. We analyse the differences between Game 0 and Game 1: 1. In Game 0, the matrix A is generated by TrapGen, and in Game 1, the matrix A is chosen uniformly random. By the Lemma 2.3, the distributions of these two ways of constructing the matrix A are statistically close. 2. In Game 0, the matrices {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1} are chosen uniformly at random from Z nÅ◊m q . In Game 1, They are computed as Ab = ARAb + bG, Cb = ARCb + bG for b = 0, 1, and Bi = ARBi + siG for i úÙ¯® [k] for random and secret low-norm matrices RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 from {1, úÙ¯≤1} mÅ◊m. By the Lemma 2.1, the distributions of these two ways of generating these public matrices are statistically close. In particular, the PRF secret key {si}iúÙ¯®[k] is information-theoretically concealed by {Bi}iúÙ¯®[k] . 3. We note that in both Game 0 and Game 1, the use of A0 or A1 of the key generation algorithms is decided by b = PRF(K, id). For a private key query on id in Game 1, let Fid,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ APRF,id = A | A(RA1úÙ¯≤b úÙ¯≤ RPRF,id) + (1 úÙ¯≤ 2b)G . Note that the publicly known trapdoor of úÙ¶˚úÙ˘Â q (G) is also a trapdoor of úÙ¶˚úÙ˘Â q ((1 úÙ¯≤ 2b)G). In Game 1, the identity key did úÙ¯® úÙ¶˚ u q (Fid,1úÙ¯≤b) is generated by SampleLeft with the trapdoor basis TA of úÙ¶˚úÙ˘Â q (A). In Game 1, did is generated by SampleRight with the trapdoor of úÙ¶˚úÙ˘Â q ((1 úÙ¯≤ 2b)G). By the Theorems 1 and 2, for sufficient large Gaussian parameter s, the identity key did will have the same distribution DúÙ¶˚u q (Fid,1úÙ¯≤b),s up to a negligibly small statistical difference. Summing up, the distributions of Game 0 and Game 1 are statistically close, and thus |Pr[S0] úÙ¯≤ Pr[S1]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Lemma 4.3. Game 2 and Game 1 are statistically indistinguishable, so |Pr[S1] úÙ¯≤ Pr[S2]| úÙ˘§ negl(úÙßª) for some negligible function negl(úÙßª). Proof. Let R = RAb úÙ¯≤ RCPRF,idúÙ¯∑ in the Sim.Encrypt algorithm. The difference between Game 1 and Game 2 is the way of generating the challenge ciphertext. In Game 1, the challenge ciphertext is generated by Encrypt, and the noise vectors are sampled from some discrete Gaussian distributions that are independent of Pub. In Game 2 the challenge ciphertext is generated by Sim.Encrypt, and R, where R is computed from RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 , PRFúÙÚ˘s key K, circuit CPRF and idúÙ¯∑ . 23 By construction, Encrypt and Sim.Encrypt generate (cb,0, c1úÙ¯≤b,0, c1úÙ¯≤b,1) in the essentially same way (besides the negligible statistical difference in their input public parameters). So (cb,0, c1úÙ¯≤b,0, c1úÙ¯≤b,1) part of the challenge ciphertexts output by Encrypt and Sim.Encrypt are statistically close. By the construction of cb,1 in the challenge ciphertext in Game 2, c > b,1 =  mod q c > 1úÙ¯≤b,1 =  s > b FidúÙ¯∑ ,b + [úÙßΩúÙ§Ê > b,1 | úÙßΩúÙ§Á > b,1 ]  mod q úÛ‚— úÛ‚‘úÛ‚“ úÛ‚‘úÛ‚” c1úÙ¯≤b,0 = s > 1úÙ¯≤bu + úÙßΩ1úÙ¯≤b,0 + Msgbq/2c  mod q c > b,1 =  Sim.KeyGen(Pub, Msk, id) Upon an input identity id = x1x2 . . . xt úÙ¯® {0, 1} t , the algorithm uses the parameters generated from Sim.Setup to do the following: 1. Compute APRF,id = ARCPRF,id + PRF(K, id)G úÙˆ EvalBV(CPRF, {Bi}iúÙ¯®[k] , Cx1 , . . . , Cxt ). 2. Let PRF(K, id) = b úÙ¯® {0, 1}. Set Fid,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,id = A | A(RA1úÙ¯≤b úÙ¯≤ RCPRF,id) + (1 úÙ¯≤ 2b)G . 3. Run SampleRight to sample did úÙ¯® DúÙ¶˚u q (Fid,1úÙ¯≤b),s as the private key Skid. Sim.Encrypt(Pub, idúÙ¯∑ , Msg) To encrypt a message MsgúÙ¯∑ úÙ¯® {0, 1} with respect to an identity idúÙ¯∑ : 1. Compute b = PRF(K, idúÙ¯∑ ). 2. Set FidúÙ¯∑ ,b = A | Ab úÙ¯≤ ACPRF,idúÙ¯∑ = A | A(RAb úÙ¯≤ RCPRF,idúÙ¯∑ ) and FidúÙ¯∑ ,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,idúÙ¯∑ = A | A(RA1úÙ¯≤b úÙ¯≤ RCPRF,idúÙ¯∑ ) + (1 úÙ¯≤ 2b)G . 21 3. Select random vectors sb, s1úÙ¯≤b $ úÙˆúÙ¯≤ Z n q . 4. Select noise scalars úÙßΩb,0, úÙßΩ1úÙ¯≤b,0 úÙˆ DZ,úÙß√LWE . 5. Sample noise vectors x, y úÙˆ DZm,úÙß√LWE for sufficiently large Gaussian parameter úÙß√LWE (úÙß√LWE úÙ˘• úÙß∑úÙßµ(Z m) for some small úÙßµ > 0). Set úÙßΩúÙ§Êb,1 = x + y. 6. Let R = RAb úÙ¯≤ RPRF,idúÙ¯∑ and ri be the i-th column of R. We sample the noise vector z = (z1, z2, . . . , zm) úÙ¯® Z m with zi úÙˆ DZ,úÙß√1,i for the sufficiently large Gaussian parameter úÙß√1,i = p úÙß√ 2 úÙ¯≤ 2(krik Å∑ úÙß√LWE) 2. 7 Set úÙßΩúÙ§Áb,1 = R> Å∑ (x úÙ¯≤ y) + z. 7. Select noise vectors úÙßΩúÙ§Ê1úÙ¯≤b,1 úÙˆ DZm, úÙ¯∫ 2úÙß√LWE , úÙßΩúÙ§Á1úÙ¯≤b,1 úÙˆ DZm,úÙß√. 8. Set the challenge ciphertext CtxidúÙ¯∑ = (cb,0, cb,1, c1úÙ¯≤b,0, c1úÙ¯≤b,1) as: úÛ‚— úÛ‚‘úÛ‚“ úÛ‚‘úÛ‚” cb,0 = s > b u + úÙßΩb,0 + Msgbq/2c  Msgbq/2c + úÙßΩb,0 úÙ¯≤ úÙßΩúÙ§Ê > 0,1d1 úÙ¯≤ úÙßΩúÙ§Á > 0,1d2  mod q Recall, the norm of d1 and d2 is bounded by s úÙ¯∫ m, and the norm of úÙßΩúÙ§Êb,1 and úÙßΩúÙ§Áb,1 is bounded by úÙß√LWEúÙ¯∫ m and úÙß√ úÙ¯∫ m respectively, by Lemma 2.4. To ensure correctness of decryption, we need |úÙßƒ | = |cb,0 úÙ¯≤ úÙßΩúÙ§Ê > b,1d1 úÙ¯≤ úÙßΩúÙ§Á > 0,1d2| úÙ˘§ |cb,0| + kúÙßΩúÙ§Ê0,1k Å∑ kd1k + kúÙßΩúÙ§Ê0,1k Å∑ kd2k úÙ˘§ O(s Å∑ m Å∑ (úÙß√LWE + úÙß√)) úÙ˘§ q/4 Accordingly, it is enough to set q such that O(s Å∑ m Å∑ (úÙß√LWE + úÙß√)) úÙ˘§ q/4. 4.3 Parameter Selection and Discussion We now discuss a consistent parameter instantiation that achieves both correctness and security. Let úÙßª be the security parameter, t = t(úÙßª) be the identity length, k = k(úÙßª) be the secret key length of PRF, and let ` = t + k be the input length of PRF. Let, for the most general case, the circuit depth of PRF be d = d(úÙßª). To ensure we can run TrapGen in the Lemma 2.3, we set m = n 1+úÙß∑ for some úÙß∑ > 0 (we assume n úÙß∑ > O(log q)). To make sure SampleLeft in the 5For instance we set úÙß√ = O(4d Å∑ m3/2 ) Å∑ úÙß…( úÙ¯∫ log m) Å∑ úÙß√LWE. 6To ensure correct decryption, the message should contain some redundancy to weed out the incorrect ciphertext. It is a standard technique to encrypt multiple bits in GPV-style encryption, by replacing u with a matrix U úÙ¯® Z nÅ◊z q in Pub with which we can now independently encrypt z > 1 bits without change to the security analysis. If hybrid encryption is used, the multiple bits can be used to encrypt a symmetric key without redundancy, deferring the integrity check to the symmetric realm where it can be performed at minimal cost. 19 real scheme and SampleRight in the simulation algorithm Sim.KeyGen (see section 4.4) have the same output distribution per Theorem 2.7, we set a sufficiently large Gaussian parameter s = kTúÙ§¸ Gk Å∑ O(4d Å∑ m3/2 ) Å∑ úÙß…( úÙ¯∫ log m). To ensure the applicability of RegevúÙÚ˘s [55] and PeikertúÙÚ˘s [54] LWE reductions from worst-case lattice problems, we set the Gaussian parameter of LWE noise distribution to be úÙß√LWE = úÙ¯∫ n. So the LWE noise distribution is (DZ, úÙ¯∫ n ) mod q. For the security proof (specifically for the proofs of Lemma 4.3 and Lemma 4.9), we set úÙß√ = O(4d Å∑ m3/2 ) Å∑ úÙß…( úÙ¯∫ log m) Å∑ úÙß√LWE. Finally, to ensure correctness condition of decryption, we set q = O(16d Å∑ m9/2 ) Å∑ (úÙß… úÙ¯∫ log m) 2 . As for our signature scheme, if we the PRF can be computed by a NC1 NAND circuit with depth d = c log ` for some constant c > 1, we can set the LWE modulus q = O(` 4c Å∑ m9/2 ) Å∑ (úÙß… úÙ¯∫ log m) 2 , which is polynomial in the security parameter úÙßª. Tight Reduction and Hardness of LWE. It is known that larger modulus results in stronger LWE assumption, if the standard deviation of the noise distribution stays unchanged. More precisely, let B be the maximum magnitude of the LWE noise, and q be the LWE modulus. The hardness of the LWE problem depends on the ratio q/B. The LWE problem becomes easier when this ratio grows. In this regard, the appeal of our tight reduction varies: tight reduction to harder LWE problem is more preferable than tight reduction to easier LWE problem. This is true particularly when one considers the average-case hardness of LWE to worst-case hardness of classic lattice problems, e.g. GapSVP and SIVP, reductions [55, 54, 22] where ratio q/B is smaller, the solutions for classic lattice problems are better. One feature of our IBE scheme (and the signature scheme it induces) is that depending on different circuits instantiations, the assumptions we male for our tight reduction may vary. In addition, if we use a LWE-based PRF, our IBE scheme relies on the stronger one of two LWE assumptions: one is made for the PRF and another one is made for our construction, which uses a polynomial modulus q as we chose above. Currently, basing our IBE scheme solely on LWE needs to assume the LWE assumption with super-polynomial modulus. This is because the state-of-art PRFs from LWE (from [9, 8]) in terms of efficiency and provable security require super-polynomial LWE modulus. On the other hand, we believe that our tight reduction is still very valuable even for large ratio q/B. Firstly, it shows that, at the first time, we actually can eliminate the dependency between the number of adversaryúÙÚ˘s queries and the security of lattice-based IBE scheme (as well as short lattice signature scheme). This is very important since the number of adversaryúÙÚ˘s queries can be quite large, which will negatively impact the schemesúÙÚ˘ security seriously. Secondly, the average-case to worst-case reduction does provide some security confidence for the LWE assumption, but this is not the whole story. For certain parameters, many classic lattice problems are NP-hard. However, those parameters have no direct connection to lattice-based cryptography. (There is even evidence that the classic lattice problems with parameters relevant cryptography are not NP-hard.) On the other hand, the LWE problem (with various parameters) could be assured to be a hard problem in its own right. It has shown robustness against various attacks in a relatively long-term period. This has made LWE widely accepted as standard assumption and for use in cryptography. For instance, even for sub-exponentially large ratios q/B = 2O(n c ) where n is the LWE dimension and 0 < c < 1/2, the LWE problem is still believed to be hard and leads to powerful cryptographic schemes which we were not able to obtain by other means, including fully homomorphic encryption, e.g. [23], attribute-based encryption for circuits, e.g. [40, 19, 25], and predicate encryption for circuits [41]. 4.4 Proof of Security The security of our IBE scheme with respect to the Definition 2.9 can be stated by the following theorem. 20 Theorem 4.1. Let úÙßª be a security parameter. The parameters n, q are chosen as the section 4.3. Let úÙß« be the distribution DZm, úÙ¯∫ n . If the (tLWE, LWE)-LWEn,q,úÙß« assumption holds and the PRF used in the IBE scheme is (tPRF, PRF)-secure, then the IBE scheme is (t, qid, )-IND-IDCPA secure such that  úÙ˘§ 2(PRF + LWE) + negl(úÙßª) for some negligible function negl(úÙßª), and max(tPRF, tLWE) úÙ˘§ t+O (qid Å∑ (TS + TE)) where TS is the maximum running time of SampleRight and TE is the maximum running time of EvalBV for one input identity. We prove above theorem through a sequence of indistinguishable security games. The first game is identical to the IND-ID-CPA game. In the last game, the adversary has no advantage. We will show that a PPT adversary will not be able to distinguish the neighboring games which will prove that the adversary has only negligibly small advantage in wining the first (real) game. Firstly, we define the following simulation algorithms Sim.Setup, Sim.KeyGen and Sim.Encrypt. Sim.Setup(1úÙßª ) The algorithm does the following: 1. Select matrix A $ úÙˆúÙ¯≤ Z nÅ◊m q . 2. Select k + 4 low-norm matrices RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 $úÙˆúÙ¯≤ {1, úÙ¯≤1} mÅ◊m. 3. Select a secure pseudorandom function PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1} and express it as a NAND Boolean circuit CPRF with depth d = d(úÙßª). 4. Select a uniformly random string K = s1s2 . . . sk $úÙˆúÙ¯≤ {0, 1} k . 5. Set Ab = ARAb + bG and Cb = ARCb + bG for b = 0, 1. 6. Set Bi = ARBi + siG for i úÙ¯® [k]. 7. Select vector u $ úÙˆúÙ¯≤ Z n q . 8. Publish Pub = A, {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1}, u, PRF, CPRF





 cb,0 úÙ¯≤ c > b,1did mod q =  cb,0 úÙ¯≤ c > b,1did mod q View úÙßƒ as an integer in (úÙ¯≤q/2, q/2]. If úÙßƒ is closer to 0 than Å±q/2, the output is Msg = 0. Otherwise, it is Msg = 1. 4.2 Correctness Following the decryption algorithm, let did = [d > 1 | d > 2 ] >. We have úÙßƒ =  mod q Decrypt(Pub, Skid, Ctxid) The decryption algorithm uses the key did to try to decrypt both (c0,0, c0,1) and (c1,0, c1,1) 6 . W.l.o.g., assume that (cb,0, cb,1) is the correct ciphertext. The decryption algorithm computes úÙßƒ =  mod q c > 1,1 = s > 1 Fid,1 + [úÙßΩúÙ§Ê > 1,1 | úÙßΩúÙ§Á > 1,1 ]  mod q úÛ‚— úÛ‚“ úÛ‚” c1,0 = s > 1 u + úÙßΩ1,0 + Msgbq/2c  mod q c > 0,1 = s > 0 Fid,0 + [úÙßΩúÙ§Ê > 0,1 | úÙßΩúÙ§Á > 0,1 ]  and the master secret key Msk = (TA, K). KeyGen(Pub, Msk, id) Upon an input identity id=x1x2 . . . xt úÙ¯® {0, 1} t , the key generation algorithm does the following: 1. Compute b = PRF(K, id). 2. Compute ACPRF,id = EvalBV(CPRF, {B}iúÙ¯®[k] , Cx1 , Cx2 , . . . , Cxt ) úÙ¯® Z nÅ◊m q . 3. Set Fid,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,id úÙ¯® Z nÅ◊2m q . 4. Run SampleLeft to sample did from the discrete Gaussian distribution DúÙ¶˚u q (Fid,1úÙ¯≤b),s hence Fid,1úÙ¯≤bdid = u (mod q). Output Skid = did. Encrypt(Pub, id, Msg) To encrypt a message Msg úÙ¯® {0, 1} with respect to an identity id = x1x2 . . . xt úÙ¯® {0, 1} t : 1. Compute ACPRF,id = EvalBV(CPRF, {Bi}iúÙ¯®[k] , Cx1 , Cx2 , . . . , Cxt ). 2. Set Fid,b = A | Ab úÙ¯≤ ACPRF,id úÙ¯® Z nÅ◊2m q for b = 0, 1. 3. Select two random vectors s0, s1 $ úÙˆúÙ¯≤ Z n q . 18 4. Select two noise scalars úÙßΩ0,0, úÙßΩ1,0 úÙˆ DZ,úÙß√LWE and four noise vectors úÙßΩúÙ§Ê0,1, úÙßΩúÙ§Ê1,1 úÙˆ DZm, úÙ¯∫ 2úÙß√LWE , úÙßΩúÙ§Á0,1, úÙßΩúÙ§Á1,1 úÙˆ DZm,úÙß√ where úÙß√ is sufficiently larger than úÙß√LWE. 5 5. Compute the ciphertext Ctxid = (c0,0, c0,1, c1,0, c1,1) as: úÛ‚— úÛ‚“ úÛ‚” c0,0 = s > 0 u + úÙßΩ0,0 + Msgbq/2c  . In the query phase, the adversary A adaptively issues messages for inquiring the corresponding signatures. Consider a message M = m1m2 . . . mt úÙ¯® {0, 1} t . B does the following to prepare the signature: 1. Compute ACPRF = ARCPRF,M+PRF(K, M)G úÙ¯® Z nÅ◊m q by EvalBV(CPRF, {Bi}iúÙ¯®[k] , Cm1 , Cm2 , . . . , Cmt ). 2. Let b = PRF(K, M), it sets FM,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,M = A | A(RA1úÙ¯≤b úÙ¯≤ RCPRF,M) + (1 úÙ¯≤ 2b)G and runs SampleRight to generate the signature Sig = dM úÙ¯‹ DúÙ¶˚úÙ˘Âq (FM,1úÙ¯≤b),s. 16 Finally, A output a forgery (d úÙ¯∑ , MúÙ¯∑ ). Let PRF(K, MúÙ¯∑ ) = b. If kdk > súÙ¯∫ 2m or A | A1úÙ¯≤b úÙ¯≤ ACPRF,MúÙ¯∑ d úÙ¯∑ = 0 (mod q), B aborts. Otherwise, we have A | Ab úÙ¯≤ ACPRF,MúÙ¯∑ d úÙ¯∑ = 0 (mod q). Let d úÙ¯∑ = [d > 1 | d > 2 ] > úÙ¯® Z 2m. B outputs e = d1 + (RAb úÙ¯≤ RCPRF,MúÙ¯∑ )d2 where kek úÙ˘§ úÙß≤ as a solution for the SISn,q,úÙß≤,m problem instance. We show that Vk output by B has the correct distribution. In the real scheme, the matrix A is generated by TrapGen. In the simulation, A has uniform distribution in Z nÅ◊m q as it comes from the SIS challenge. By the Lemma 2.3, A generated in the simulation has right distribution except a negligibly small statistical error. Secondly, the matrices A, {A0, A1}, {Bi}iúÙ¯®[k] , and {C0, C1} computed in the simulation have distribution that is statistically close to uniform distribution in Z nÅ◊m q by the Lemma 2.1. In particular, the PRF secret key {si}iúÙ¯®[k] is information-theoretically concealed by {Bi}iúÙ¯®[k] . Now we show that given {A0, A1}, {Bi}iúÙ¯®[k] , and {C0, C1}, it is hard to find two messages M 6= M0 such that ACPRF,M = ACPRF,M0. Assume an efficient adversary finds M 6= M0 such that ACPRF,M = ACPRF,M0. With the public parameters set up above, we have ARCPRF,M + PRF(K, M)G = ARCPRF,M0 + PRF(K, M0 )G If PRF(K, M) 6= PRF(K, M0 ), which will happen essentially 1/2 probability if PRF is secure, we have RCPRF,M 6= RCPRF,M0 and A(RCPRF,M úÙ¯≤ RCPRF,M0) Å± G = 0 (mod q). By Lemma 2.8 and Algorithm 1, a low-norm vector dÅØ úÙ¯® Z mÅ◊m can be efficiently found such that GdÅØ = 0 (mod q) where dÅØ 6= 0 and dÅØ úÙ˘§ s 0úÙ¯∫ m for some Gaussian parameter s 0 úÙ˘• úÙ¯∫ 5 Å∑ úÙß…( úÙ¯∫ log m). Then (RCPRF,M úÙ¯≤ RCPRF,M0) Å∑ dÅØ will be a non-zero vector with all but negligible probability and, therefore, a valid the SIS solution for A. In the query phase, the signatures replied to A have the correct distribution under the predefined conditions. Indeed, by the Theorem 2.7, for sufficient large Gaussian parameter s, the the distribution of signatures generated in the simulation by SampleRight is statistically close to DúÙ¶˚úÙ˘Âq (FM,1úÙ¯≤b),s where the distribution of signatures generated in the real scheme by SampleLeft is also statistically close to DúÙ¶˚úÙ˘Âq (FM,1úÙ¯≤b),s. In the forge phase, A will have at most advantage PRF in predicting the bit value b with respect to the message it wants to forge. Therefore, if A can not distinguish PRF from random functions, it will randomly pick either of the matrices A0 or A1 to make a forgery. With 1 2 chance it will pick the one that B will be able to use to solve the SIS problem. So we have SIS úÙ˘• /2úÙ¯≤PRF úÙ¯≤negl(úÙßª) where negl(úÙßª) stands for negligible statistical error in the simulation. To argue that e = d1 + (RA1 úÙ¯≤ RCPRF,MúÙ¯∑ )d2 is a valid solution of the SISn,q,úÙß≤,m problem instance, we need to show e is sufficiently short, and non-zero except with negligible probability. First of all, we have A | Ab úÙ¯≤ ACPRF,MúÙ¯∑ d úÙ¯∑ = A | A(RAb úÙ¯≤ RCPRF,MúÙ¯∑ ) d úÙ¯∑ = Ad1 + A(RAb úÙ¯≤ RCPRF,MúÙ¯∑ )d2 = A (d1 + R Å∑ d2) = 0 (mod q) where R = RAb úÙ¯≤RCPRF,MúÙ¯∑ . Since d1, d2 have distribution DZm,s with condition d úÙ¯® úÙ¶˚ úÙ˘Â q (FM,b), by the Lemma 2.4, d1, d2 úÙ˘§ s úÙ¯∫ m. By Lemma 2.11, we have kek úÙ˘§ kd1k + kRk2 Å∑ kd2k úÙ˘§ O(4d Å∑ m3/2 ) Å∑ s úÙ¯∫ m. Let úÙß≤ úÙ˘• O(4d Å∑ m3/2 ) Å∑ s úÙ¯∫ m is sufficient. It remains to show that e = d1 + R Å∑ d2 6= 0. Suppose d2 6= 0, we have e 6= 0 since d 6= 0. On the other hand, we have d2 = (d1, . . . , dm) > 6= 0 and, thus, at least one coordinate of d2, say dj , is not 0. We write R = (r1, . . . , rm) and so R Å∑ d2 = rj Å∑ dj + Xm i=1,i6=j ri Å∑ di 17 Observe that for the fixed message MúÙ¯∑ on which A made the forgery, R (therefore rj ) depends on the low-norm matrices RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 and the secret key of PRF. The only information about rj for A is from the public matrices in Vk, i.e. {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1}. So by the pigeonhole principle there is a (exponentially) large freedom to pick a value to rj which is compatible with AúÙÚ˘s view, i.e. Ar0 j = Ar00 j (mod q) for admissible (low-norm) r 0 j , r 00 j where r 0 j 6= r 00 j . (In fact, here we have more freedom than the case in [21] where R is picked from {1, úÙ¯≤1} mÅ◊m). Finally, to answer one signing query, BúÙÚ˘s running time is bounded by O(TS + TE). So the total running time of B in the simulation is bounded by O(qs(TS + TE)) This concludes the proof. 4 IBE with Tight Security 4.1 Construction with CPA Security Setup(1úÙßª ) The setup algorithm takes as input a security parameter úÙßª. It does the following: 1. Sample a random matrix A úÙ¯® Z nÅ◊m q along with a trapdoor basis TA úÙ¯® Z mÅ◊m of lattice úÙ¶˚ úÙ˘Â q (A) by running TrapGen. 2. Select random matrices A0, A1, random úÙÚ¸PRF keyúÙÚ˝ matrices B1, . . . , Bk, and random úÙÚ¸PRF inputúÙÚ˝ matrices C0, C1 from Z nÅ◊m q uniformly at random. 3. Select a random vector u $ úÙˆúÙ¯≤ Z n q . 4. Select a secure pseudorandom function PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1}, express it as a NAND Boolean circuit CPRF with depth d = d(úÙßª), and select a PRF key K = s1s2 . . . sk $ úÙˆúÙ¯≤ {0, 1} k . 5. Output the public parameters Pub = A, {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1}, u, PRF, CPRF



 , Sk = (TA, K) Sign(Vk, Sk, M) The signing algorithm takes as input the public verification key Vk, the signing key Sk and a message M = m1m2 . . . mt úÙ¯® {0, 1} t . It does: 1. Compute ACPRF,M = EvalBV(CPRF, {Bi}iúÙ¯®[k] , Cm1 , Cm2 , . . . , Cmt ) úÙ¯® Z nÅ◊m q . 4 2. Compute bit value b = PRF(K, M) and set FM,1úÙ¯≤b = A | A1úÙ¯≤b úÙ¯≤ ACPRF,M . 3. Run SampleLeft to sample dM úÙ¯® Z 2m with distribution DúÙ¶˚úÙ˘Âq (FM,1úÙ¯≤b),s. 4. Output the signature Sig = dM. Ver(Vk, M, Sig) The verification algorithm takes as input the verification key Vk, message M and the signature of M, verifies as follows: 1. Assume Sig = d. It checks if d úÙ¯® Z 2m, d 6= 0, and kdk úÙ˘§ s úÙ¯∫ 2m. 2. Compute ACPRF,M = EvalBV(CPRF, {Bi}iúÙ¯®[k] , Cm1 , Cm2 , . . . , Cmt ) úÙ¯® Z nÅ◊m q . Check if FM,bd = A | Ab úÙ¯≤ ACPRF,M d = 0 (mod q) for b = 0 or 1. 3. If all above verifications pass, accept the signature; otherwise, reject. 3.2 Parameters Selection and Discussion Let úÙßª be the security parameter, we set n = n(úÙßª), let the message length be t = t(úÙßª) and the secret key length of PRF be k = k(úÙßª). For the most general case, let the circuit depth of CPRF be d = d(úÙßª). To ensure we can run TrapGen in the Lemma 2.3, we set m = n 1+úÙß∑ for some úÙß∑ (we assume n úÙß∑ > O(log q)). To run SampleLeft and SampleRight in the real scheme and simulation per Theorem 2.7, we set s sufficiently large such that s > kTúÙ§¸ Gk Å∑ kRk2 Å∑ úÙß…( úÙ¯∫ log m) for R = RAb úÙ¯≤ RCPRF,M (see the security proof below). By Lemma 2.11 we set s = O(4d Å∑ m3/2 ) Å∑ úÙß…( úÙ¯∫ log m). For the SIS parameter úÙß≤, we need úÙß≤ úÙ˘• O(4d Å∑ m3/2 Å∑ s úÙ¯∫ 2m). So we set úÙß≤ = O(16d Å∑ m7/2 ) Å∑ úÙß…( úÙ¯∫ log m). To ensure the applicability of the average-case to worst-case reduction for SIS, we need q úÙ˘• úÙß≤ Å∑ úÙß…( úÙ¯∫ n log n). So we set q = O(16d Å∑ m4 ) Å∑ (úÙß…( úÙ¯∫ log m))2 . 4 It turns out that if PRF is secure, an efficient SIS algorithm can be tightly reduced to an efficient algorithm that finds M 6= M0 such that ACPRF,M = ACPRF,M0 . We prove this in the section 3.3. 15 Particularly, if we choose PRF from the well-known efficient and provably secure candidates of PRFs like the ones from [53, 31, 47, 9, 8] can be computed by NC1 circuits, let ` = t + k be the input length of PRF (which is a polynomial in the security parameter), the circuit depth of CPRF will be d = c log ` for some constant c. In this case we can set úÙß≤ = O(` 4c Å∑m7/2 )Å∑úÙß…( úÙ¯∫ log m) and q = O(` 4c Å∑ m4 ) Å∑ (úÙß…( úÙ¯∫ log m))2 which are polynomial in the security parameter. It needs to mention that if we instantiate PRF by the (direct) LWE-based PRF from [9] or by the LWE-based PRF from [8] whose security relies on LWE assumption with superpolynomial modulus, the security of our signature scheme has to rely on LWE assumption with super-polynomial modulus. Such LWE assumption is stronger than the SIS assumption with polynomial modulus (as we set above) from which we make the proof for the following theorem. 3.3 Security of the Signature Scheme The security of our signature scheme is stated by the following theorem. Theorem 3.1. Let úÙßª be a security parameter. The parameters n, m, and q are chosen as the section 3.2. If the (tSIS, SIS)-SISn,q,úÙß≤,m assumption holds and the PRF used in the signature scheme is (tPRF, PRF)-secure, the signature scheme is (t, qs, )-EUF-CMA secure where SIS úÙ˘• /2 úÙ¯≤ PRF úÙ¯≤ negl(úÙßª), for some negligible statistical error negl(úÙßª), and max(tPRF, tSIS) úÙ˘§ t + O(qs Å∑ (TS + TE)) where qs is the number of signing query, TS is the maximum running time of SampleRight, and TE is the maximum running time of EvalBV for one input message. Proof. Consider the following security game between an adversary A and a simulator B. Upon receiving a SISn,q,úÙß≤,m challenge A úÙ¯® Z nÅ◊m q , the challenger B prepares Vk as follows: 1. Select k + 4 matrices RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 $úÙˆúÙ¯≤ {1, úÙ¯≤1} mÅ◊m. 2. Select a secure pseudorandom function PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1} and express it as a NAND Boolean circuit CPRF with depth d. 3. Select a PRF key K = s1s2 . . . sk $úÙˆúÙ¯≤ {0, 1} k . 4. Set Ab = ARAb + bG and Cb = ARCb + bG for b = 0, 1. 5. Set Bi = ARBi + siG for i úÙ¯® [k]. 6. Select a Gaussian parameter s > 0. 7. Publish Vk = A, {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1}, PRF, CPRF





 on R m with center c and parameter úÙß√. Define the discrete Gaussian distribution over úÙ¶˚ with center c and parameter úÙß√ as DúÙ¶˚,úÙß√ = úÙß¡úÙß√,c(y)/úÙß¡úÙß√(úÙ¶˚) for úÙ¯†y úÙ¯® úÙ¶˚, where úÙß¡úÙß√(úÙ¶˚) = P xúÙ¯®úÙ¶˚ úÙß¡úÙß√,c(x). For notational convenience, úÙß¡úÙß√,0 and DúÙ¶˚,úÙß√,0 are abbreviated as úÙß¡úÙß√ and DúÙ¶˚,úÙß√. The following lemma bounds the length of a discrete Gaussian vector with sufficiently large Gaussian parameter. Lemma 2.4 ([52]). For any lattice úÙ¶˚ of integer dimension m with basis T, c úÙ¯® R m and Gaussian parameter úÙß√ úÙ˘• kTúÙ§¸ k Å∑ úÙß…( úÙ¯∫ log m), we have Pr[kx úÙ¯≤ ck > úÙß√úÙ¯∫ m : x úÙˆ DúÙ¶˚,úÙß√,c] úÙ˘§ negl(n). Smoothing Parameter. We recall the very important notion of smoothing parameter of a lattice úÙ¶˚. It is the smallest value of s such that the discrete Gaussian DúÙ¶˚,s úÙÚ¸behavesúÙÚ˝ like a continuous Gaussian. Definition 2.3 ([52]). For any lattice úÙ¶˚ and positive real tolerance  > 0, the smoothing parameter úÙß∑(úÙ¶˚) is the smallest real s > 0 such that úÙß¡1/s(úÙ¶˚úÙ¯∑ \ {0}) < . We will make use of the following lemma, which is a special case of Corollary 3.10 from [55]. Lemma 2.5 (special case of Corollary 3.10 of [55]). Let r úÙ¯® Z m be a vector and r, úÙß± > 0 be reals. Assume that 1/ p 1/r2 + (krk/úÙß±) 2 úÙ˘• úÙß∑(Z m) for some  < 1/2. Let y be a vector with distribution DZm,r and e be a scalar with distribution DZ,úÙß±. The distribution of hr, yi + e is statistically close to DZ, úÙ¯∫ (rkrk) 2+úÙß±2 . 9 2.1.3 Lattice Sampling Algorithms Our constructions make use of the úÙÚ¸two-sided trapdoorúÙÚ˝ framework from [2, 21] which consists of two sampling algorithms SampleLeft and SampleRight. Algorithm SampleLeft(A, B, TA, u, s) (1) Inputs: a full-rank matrix A úÙ¯® Z nÅ◊m q and a short basis TA of úÙ¶˚úÙ˘Â q (A), a matrix B úÙ¯® Z nÅ◊m1 q , a vector u úÙ¯® Z n q , and a Gaussian parameter s. Output: Let F = A | B . The algorithm outputs a vector d úÙ¯® Z m+m1 in the set úÙ¶˚u q (F). Theorem 2.6 ([2, 28]). Let q > 2, m > n and s > kTúÙ§¸ Ak Å∑ úÙß…( p log(m + m1)). Then the algorithm SampleLeft(A, B, TA, u, s) taking inputs as in (1), outputs a vector d úÙ¯® Z m+m1 distributed statistically close to DúÙ¶˚u q (F),s. Algorithm SampleRight(A, B, R, TB, u, s) (2) Inputs: matrices A úÙ¯® Z nÅ◊k q and R úÙ¯® Z kÅ◊m, a full-rank matrix B úÙ¯® Z nÅ◊m q , a short basis TB of úÙ¶˚úÙ˘Â q (B), a vector u úÙ¯® Z n q , and a Gaussian parameter s. Output: Let F = A | AR + B ; the algorithm outputs a vector d úÙ¯® Z m+m1 in the set úÙ¶˚u q (F) Theorem 2.7 ([2], Theorem 19). Let q > 2, m > n. Let s > kTúÙ§¸ Bk Å∑ kRk2 Å∑ úÙß…( úÙ¯∫ log m). Then SampleRight(A, B, R, TB, u, s) taking inputs as in (2), outputs a vector d úÙ¯® Z m+k distributed statistically close to DúÙ¶˚u q (F),s. 2.1.4 Gadget Matrix The úÙÚ¸gadget matrixúÙÚ˝ G defined in [51]. We recall the following two facts. Lemma 2.8 ([51], Theorem 1). Let q be a prime, and n, m be integers with m = n log q. There is a fixed full-rank matrix G úÙ¯® Z nÅ◊m q such that the lattice úÙ¶˚ úÙ˘Â q (G) has a publicly known trapdoor matrix TG úÙ¯® Z nÅ◊m with kTúÙ§¸ Gk úÙ˘§ úÙ¯∫ 5. Lemma 2.9 ([19], Lemma 2.1). There is a deterministic algorithm, denoted GúÙ¯≤1 (Å∑) : Z nÅ◊m q úÙˆÚ Z mÅ◊m, that takes any matrix A úÙ¯® Z nÅ◊m q as input, and outputs the preimage GúÙ¯≤1 (A) of A such that G Å∑ GúÙ¯≤1 (A) = A (mod q) and kGúÙ¯≤1 (A)k úÙ˘§ m. 2.1.5 Computational Assumptions We recall the two most mainstream and conservative average-case computational assumptions for lattice problems. The learning with errors problem was first proposed by Regev [55]. For a vector s $ úÙˆúÙ¯≤ Z n q and a noise distribution úÙß« over Zq, let As,úÙß« be the distribution over Z n q Å◊ Zq by taking a $ úÙˆúÙ¯≤ Z n q and x úÙˆ úÙß«, and outputting (a, s >a + x) (mod q). Usually, úÙß« is a discrete Gaussian DZ,úÙß±q for some úÙß± < 1, reduced modulo q. We refer to [55] for further details. Definition 2.4. For a security parameter úÙ¶˚, let a positive integer n = n(úÙßª), a prime q = q(úÙßª), and a distribution úÙß« over Zq. The learning with errors problem LWEn,q,úÙß« is to distinguish the oracle Os, which outputs samples from the distribution As,úÙß«, from the oracle O$ , which outputs samples from the uniform distribution over Z n q Å◊ Zq, for an unspecified polynomial number of queries. We define the advantage (in the security parameter úÙßª) of an algorithm A in solving the LWEn,q,úÙß« problem as AdvLWEn,q,úÙß« A (úÙßª) = Pr[A Os (1úÙßª ) = 1] úÙ¯≤ Pr[A O$ (1úÙßª ) = 1] 10 We say that the (t, LWE)-LWEn,q,úÙß« assumption holds if no t-time algorithm A that has advantage at least LWE in solving the LWEn,q,úÙß« problem. For polynomial size q in úÙßª, there are known quantum [55] and classical [22] reductions from the average-case LWEn,q,úÙß« assumption to many standard worst-case lattice problems (e.g., GapSVP). 3 Peikert [54] also gave a classic reduction that applies (only) for exponential moduli q in úÙßª. These reductions further strengthen the appeal of the LWE assumption. The security of our adaptively secure signature scheme is based on the SIS problem, which can be seen as an average-case approximate shortest vector problem on random integer lattices. In a sense, SIS is the computational counterpart to the decisional LWE. Definition 2.5. For a security parameter úÙßª, let n = n(úÙßª), m = m(úÙßª), and úÙß≤ = úÙß≤(úÙßª). Let q be a prime integer. The short integer solution problem SISn,q,úÙß≤,m is as follows. Given a uniform random matrix A $ úÙˆúÙ¯≤ Z nÅ◊m q , find a non-zero vector e úÙ¯® Z m such that Ae = 0 (mod q) and kek úÙ˘§ úÙß≤. We define the advantage (function of the security parameter úÙßª) of an algorithm A in solving the SISn,q,úÙß≤,m problem as AdvSISn,q,úÙß≤,m A (úÙßª) = úÛ‚Œ úÛ‚– Ae = 0 (mod q) and kek úÙ˘§ úÙß≤, and e 6= 0. : A $ úÙˆúÙ¯≤ Z nÅ◊m q e úÙˆ A(1úÙßª , A) úÛ‚Ÿ úÛ‚€ We say the (t, SIS)-SISn,q,úÙß≤,m assumption holds if no t-time algorithm A that has advantage at least SIS in solving the SISn,q,úÙß≤,m problem. It has been shown in [52] that solving the average-case instances of the SISn,q,úÙß≤,m problem for certain parameters is as hard as solving worst-case instances of the approximate Shortest Independent Vector Problem (SIVP). 2.2 Pseudorandom Functions Definition 2.6 (Pseudorandom Functions). Let úÙßª > 0 be the security parameter, and let k = k(úÙßª), t = t(úÙßª) and l = l(úÙßª). A pseudorandom function PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1} l is an efficiently computable, deterministic two-input function where the first input, denoted by K, is the key. Let úÙıÊ be the set of all functions that map t bits strings to l bits strings. We define the advantage (in the security parameter úÙßª) of an adversary A in attacking the PRF as AdvPRF,A(úÙßª) = Pr[A PRF(K,Å∑) (1úÙßª ) = 1] úÙ¯≤ Pr[A F(Å∑) (1úÙßª ) = 1] where the probability is taken over a uniform choice of key K $úÙˆúÙ¯≤ {0, 1} k and F $ úÙˆúÙ¯≤ úÙıÊ, and the randomness of A. We say that PRF is (tPRF, PRF)-secure if for all tPRF-time adversaries A, AdvPRF,A(úÙßª) úÙ˘§ PRF. 2.3 Key-Homomorphic Evaluation Algorithm Recall the matrix key-homomorphic evaluation algorithm, which is developed by Gentry et al. [37], Boneh et al. [19] and Brakerski and Vaikuntanathan [24] in the context of fully homomorphic encryption and attribute-based encryption, works generally in the following. Given a fan-in-2 Boolean NAND circuits C : {0, 1} ` úÙˆÚ {0, 1}, ` different matrices {Ai = ARi + xiG úÙ¯® Z nÅ◊m q }iúÙ¯®[`] which correspond to each input wire of C where A $ úÙˆúÙ¯≤ Z nÅ◊m q , Ri $úÙˆúÙ¯≤ {1, úÙ¯≤1} mÅ◊m, xi úÙ¯® {0, 1} and G úÙ¯® Z nÅ◊m q is the gadget matrix, the key-homomorphic evaluation algorithm 3Equivalently, this is to say that many classic worst-case lattice problems reduce to the average-case LWE problem, for suitable parameters. 11 deterministically computes AC = ARC + C(x1, . . . , x`)G úÙ¯® Z nÅ◊m q where RC úÙ¯® Z mÅ◊m has low norm and C(x1, . . . , x`) úÙ¯® {0, 1} is the output bit of C on the arguments x1, . . . , x` . This is done, in general, by inductively evaluating each NAND gate. For a NAND gate g(u, v; w) with input wires u, v and output wire w, matrices Au = ARu + xuG and Av = ARv + xvG where xu and xv are input bits of u and v respectively, the evaluation algorithm computes Aw = G úÙ¯≤ Au Å∑ GúÙ¯≤1 (Av) = G úÙ¯≤ (ARu + xuG) Å∑ GúÙ¯≤1 (ARv + xvG) = ARg + (1 úÙ¯≤ xuxv)G where 1 úÙ¯≤ xuxv def = NAND(xu, xv), and Rg = úÙ¯≤Ru Å∑ GúÙ¯≤1 (Av) úÙ¯≤ xuRv has low-norm if Ru, Rv have low-norm. In this paper, we consider evaluating circuits of PRFs. Most of the well-known PRFs from number-theoretic assumptions (e.g. [53, 47]) and lattice assumptions (e.g. [9, 8]) can be computed by circuits in class NC1 (i.e. with polynomial size, logarithmic depth O(log `) in input length ` and fan-in 2). For circuits in NC1 , by applying above procedure in a general treefashion, the norm of RC in the matrix AC is roughly bounded by mO(log `) , which in turn usually results in superpolynomial or sub-exponential LWE/SIS modulus q (in the security parameter) in certain applications. In [24], Brakerski and Vaikuntanathan observed that the norm of RC matrix in above homomorphic evaluation is accumulated in an asymmetric way. They exploited this feature to design a special evaluation algorithm that evaluates NC1 circuits with moderately increasing the norm of RC. Specifically, the observation is that any circuit with depth d can be simulated by a length-4d and width-5 branching program, through the BarringtonúÙÚ˘s theorem. Such a branching program can be computed by multiplying 4d 5-by-5 permutation matrices. It is showed in [24] that homomorphically evaluating the multiplication of permutation matrices using above homomorphic evaluation procedure and the asymmetrical noise-growth feature only increases the noise by a polynomial factor and, therefore, allows us to use polynomial size LWE/SIS modulus q in the security parameter. Such result has been used to construct efficient ABE scheme for branching programs (with bounded length) from LWE with polynomial modulus [42]. In our constructions, we particularly use the Brakerski and VaikuntanathanúÙÚ˘s evaluation algorithm [24] and denote it by EvalBV. We recall the BarringtonúÙÚ˘s Theorem. Theorem 2.10 (BarringtonúÙÚ˘s Theorem). Every Boolean NAND circuit C that acts on ` inputs and has depth d can be computed by a width-5 permutation branching program úÙß† of length 4 d . Given the description of the circuit úÙß®, the description of the branching program C can be computed in poly(`, 4 d ) time. The following theorem follows from the Claim 3.4.2 and Lemma 3.6 of [24] and the BarringtonúÙÚ˘s Theorem. Lemma 2.11. Let C : {0, 1} ` úÙˆÚ {0, 1} be a NAND Boolean circuit. Let {Ai = ARi + xiG úÙ¯® Z nÅ◊m q }iúÙ¯®[`] be ` different matrices correspond to each input wire of C where A $ úÙˆúÙ¯≤ Z nÅ◊m q , Ri $ úÙˆúÙ¯≤ {1, úÙ¯≤1} mÅ◊m, xi úÙ¯® {0, 1} and G úÙ¯® Z nÅ◊m q is the gadget matrix. There is an efficient deterministic algorithm EvalBV that takes as input C and {Ai}iúÙ¯®[`] and outputs a matrix AC = ARC + C(x1, . . . , x`)G = EvalBV(C, A1, . . . , A`) where RC úÙ¯® Z mÅ◊m and C(x1, . . . , x`) is the output of C on the arguments x1, . . . , x` . EvalBV runs in time poly(4d , `, n, log q). Let kRmaxk2 = max {kRik2 }iúÙ¯®[`] , the norm of RC in AC output by EvalBV can be bounded,with 12 overwhelming probability, by kRCk2 úÙ˘§ O(L Å∑ kRmaxk2 Å∑ m) úÙ˘§ O(L Å∑ 12úÙ¯∫ 2 Å∑ úÙ¯∫ m Å∑ m) úÙ˘§ O(4d Å∑ m3/2 ) where L is the length of the width-5 branching program which simulates C and kRik2 úÙ˘§ 12úÙ¯∫ 2m for i úÙ¯® [`] with overwhelming probability, by Lemma 2.2. Particularly, if C has depth d = c log ` for some constant c, i.e. C is in NC1 , we have L = 4d = ` 2c and kRCk2 úÙ˘§ O(` 2c Å∑ m3/2 ). Remark. In our constructions, the circuit of an instantiated PRF serves as a part of verifi- cation key (in the signature case) or public parameters (in the IBE case). This is in contrast to the FHE and ABE cases addressed by [37, 19, 24] in which circuits can be dynamically chosen by participants of protocols. Therefore further optimization on such a specific PRF circuit (e.g. depth, number of gates) could be possible. Here we consider circuit class NC1 as a more general case to include almost all efficient and provably secure PRF candidates. 2.4 Digital Signatures A digital signature scheme consists of three PPT algorithms: KeyGen, Sign, and Ver. The algorithm KeyGen takes as input a security parameter and generates a public verification key Vk and a private signing key Sk. The signing algorithm Sign takes as input the signing key Sk and a massage M, and outputs the signature Sig of M. The verification algorithm Ver takes as input a signature-message pair (Sig, M) as well as the verification key Vk. It outputs 1 if Sig is valid, or 0 if Sig is invalid. We review the standard security notion of digital signature schemes. The existential unforgeability under chosen-message attack (EUF-CMA) of a digital signature scheme úÙß† is defined through the following security game between an adversary A and a challenger B. Setup. B runs Setup(1úÙßª ) úÙˆÚ (Sk, Vk), and passes Vk to A. Query. A adaptively selects messages M1, . . . , Mqs to ask for the corresponding signatures under Vk from B. For the query Mi , B responds with a signature Sigi úÙˆ Sign(Sk, Mi). Forge. A outputs a pair (SigúÙ¯∑ , MúÙ¯∑ ) and wins if 1. MúÙ¯∑ úÙ¯® { / M1, . . . , Mqs }, and 2. Ver(Vk, SigúÙ¯∑ , MúÙ¯∑ ) úÙˆÚ 1. We refer to such an adversary A as EUF-CMA adversary. We define the advantage (in the security parameter úÙßª) AdvúÙß†,A(úÙßª) of A in attacking a digital signature scheme úÙß† to be the probability that A wins above game. Definition 2.7. For a security parameter úÙßª, let t = t(úÙßª), qs = qs(úÙßª) and  = (úÙßª). We say that a digital signature scheme úÙß† is (t, qs, )-EUF-CMA secure if for any t time EUF-CMA adversary A that makes at most qs signing queries and has AdvúÙß†,A(úÙßª) úÙ˘§ . 2.5 Identity-Based Encryption An Identity-Based Encryption system (IBE) consists of four PPT algorithms: Setup, KeyGen, Encrypt, and Decrypt. The algorithm Setup takes as input a security parameter and generates public parameters Pub and a master secret key Msk. The algorithm KeyGen uses the master 13 secret key Msk to produce an identity private key Skid corresponding to an identity id. The algorithm Encrypt takes the public parameters Pub to encrypt messages for any given identity id. The algorithm Decrypt decrypts ciphertexts using the identity private key if the identity of the ciphertext matches the identity of the private key. We review the security model of IBE proposed in [18]. It defines the indistinguishability of ciphertexts under an adaptive chosen-ciphertext and adaptive chosen-identity attack (IND-IDCCA2). The IND-ID-CCA2 security of IBE is defined through the following game between an adversary A and a challenger B. For a security parameter úÙßª, let MúÙßª be the message space and CúÙßª be the ciphertext space. Setup. B runs Setup(1úÙßª ) úÙˆÚ (Pub, Msk), passes the public parameters Pub to A, and keeps the master secret Msk. Phase 1. A adaptively issues queries q1, . . . , qm where each query qi is one of: úÙÛ¢ Private key query for identity idi . B runs KeyGen to generate Skidi and sends it to A. úÙÛ¢ Decryption query for a ciphertext Ctxidi under identity idi . B runs KeyGen to generate Skidi . Then, B runs the decryption algorithm to decrypt Ctxidi and returns the message to A. Challenge. When A decides the Phase 1 is over, it outputs a challenge identity idúÙ¯∑ , which is not been queried during Phase 1, and two equal length messages Msg0 , Msg1 úÙ¯® MúÙßª. B flips a fair coin úÙß≥ $úÙˆúÙ¯≤ {0, 1} and sets CtxidúÙ¯∑ úÙˆ Encrypt(Pub, MsgúÙß≥ , idúÙ¯∑ ). Finally A passes CtxidúÙ¯∑ to A. Phase 2. A adaptively issues more queries qm+1, . . . , qn where qi is one of úÙÛ¢ Private key query for identity idi 6= idúÙ¯∑ . úÙÛ¢ Decryption query for a ciphertext Ctxidi 6= CtxidúÙ¯∑ . In both cases, B responds as in Phase 1. Guess. A outputs úÙß≥ 0 úÙ¯® {0, 1} and it wins if úÙß≥ 0 = úÙß≥. We refer to such an adversary A as an IND-ID-CCA2 adversary. We define the advantage (in the security parameter úÙßª) of A in attacking an IBE scheme E as AdvE,A(úÙßª) = |Pr[úÙß≥ 0 = úÙß≥] úÙ¯≤ 1/2|. Definition 2.8. For a security parameter úÙßª, let t = t(úÙßª), qid = qid(úÙßª), qCtx = qCtx(úÙßª), and  = (úÙßª). We say that an IBE system E is (t, qid, qCtx, )-IND-ID-CCA2 secure if for any t-time IND-ID-CCA2 adversary A that makes at most qid private key queries and at most qCtx decryption queries, we have AdvE,A(úÙßª) úÙ˘§ . Chosen-Plaintext Security. We define the chosen-plaintext security (IND-ID-CPA) for IBE systems as in above security game, except the adversary is not allowed to issue decryption queries. The adversary is still able to adaptively make private key queries. Definition 2.9. We say that an IBE system E is (t, qid, )-IND-ID-CPA secure if E is (t, qid, 0, )- IND-ID-CCA2 secure. Selective Security. A weaker and less realistic security model of IBE system, introduced in [27], is the selective security model in which adversary is required to commit to the challenge identity even before seeing the public parameters. We note that under computational assumptions with sub-exponential hardness, a selectively secure IBE is also adaptively secure through a standard úÙÚ¸complexity leveragingúÙÚ˝ argument from [14]; however, complexity leveraging incurs a rather severe loss of tightness in the security reduction, causing the resulting scheme to suffer from a possibly large loss of efficiency per a similar argument as discussed in the introduction. 14 3 Signature Scheme with Tight Security 3.1 Constructions KeyGen(1úÙßª ) The key generation algorithm does the following. 1. Sample a matrix A along with a trapdoor basis of lattice úÙ¶˚úÙ˘Â q (A) by TrapGen. 2. Select matrices A0, A1, úÙÚ¸PRF keyúÙÚ˝ matrices B1, . . . , Bk, and úÙÚ¸PRF inputúÙÚ˝ matrices C0, C1 from Z nÅ◊m q uniformly at random. 3. Select a secure pseudorandom function PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1}, express it as a NAND Boolean circuit CPRF with depth d = d(úÙßª), and select a PRF key K = s1s2 . . . sk $ úÙˆúÙ¯≤ {0, 1} k . 4. Select a Gaussian parameter s > 0. 5. Output the verification key and signing key as: Vk = A, {A0, A1}, {Bi}iúÙ¯®[k] , {C0, C1}, s, PRF, CPRF




















Towards Tightly Secure Short Signature and IBE Xavier Boyen, Qinyi Li Queensland University of Technology, Brisbane, Australia Abstract Constructing short signatures with tight security from standard assumptions is a longstanding open problem. We present an adaptively secure, short (and stateless) signature scheme, featuring a constant security loss relative to a conservative hardness assumption, Short Integer Solution (SIS), and the security of a concretely instantiated pseudorandom function (PRF). This gives a class of tightly secure short lattice signature schemes whose security is based on SIS and the underlying assumption of the instantiated PRF. Our signature construction further extends to give a class of tightly and adaptively secure úÙÚ¸compactúÙÚ˝ Identity-Based Encryption (IBE) schemes, reducible with constant security loss from RegevúÙÚ˘s vanilla Learning With Errors (LWE) hardness assumption and the security of a concretely instantiated PRF. Our approach is a novel combination of a number of techniques, including Katz and Wang signature, Agrawal et al. lattice-based secure IBE, and Boneh et al. key-homomorphic encryption. Our results, at the first time, eliminate the dependency between the number of adversaryúÙÚ˘s queries and the security of short signature/IBE schemes in the context of latticebased cryptography. They also indicate that tightly secure PRFs (with constant security loss) would imply tightly, adaptively secure short signature and IBE schemes (with constant security loss). 1 Introduction Short signatures are useful and desirable for providing data authenticity in low-bandwidth and/or high-throughput applications where many signatures have to be processed very quickly. Most digital signature schemes are based on computationally hard problems on specific algebraic groups, e.g., finite fields, curves, and lattices. A signature is úÙÚ¸shortúÙÚ˝ if the signature consists in a (small) constant number of group elements (e.g., field elements or lattice points). Although bare-bones signatures can be obtained from very weak assumptions (e.g., collisionresistant hash functions), constructing efficient short signatures satisfying standard security requirements (e.g., existential unforgeability under adaptively chosen-message attacks), from reasonable assumptions, appears to be a challenging task. Some of the existing short signature schemes use random oracles, e.g., [20, 10, 48, 36, 50], or rely on non-standard computational assumptions (strong, interactive assumptions, and/or q-type parametric assumptions), e.g., [34, 30, 33, 16, 26], or require signers to maintain state across signatures, e.g., [45]. The first short signature scheme from a reasonable and non-parametric assumption without random oracles was proposed by Waters [56]. Hohenberger and Waters later proposed a short signature scheme from standard RSA [46]. Lattice-based short signatures from the very mild SIS assumption in the standard model were proposed in [21, 51]. Recently, the úÙÚ¸confined guessingúÙÚ˝ technique developed by BÅ®ohl et al. [13] has produced short signatures from standard RSA and bilinear-group CDH assumptions, and also from the ring-SIS/SIS assumption in combination with lattice techniques [32, 4] with very loose reductions. Despite these elegant constructions, signature schemes that are short and enjoy tight security reductions to standard assumptions in the standard model (without random oracle), remain 1 unknown. Existing tightly secure signature schemes either have large signature size, e.g., [43, 1, 11], or merely have heuristic security arguments based on random oracles, e.g., [48, 38]. We have not been able to ascertain the earliest occurrence of this long-standing folklore problem in cryptography, but here [11] is one recent formulation: Open Problem #1úÙÚÙTightly Secure Short Signatures úÙÚ¸Construct a tightly secure and short (in the sense that the signature contains constant number of group elements or vectors and the security loss is a constant) signature scheme from standard assumptions.úÙÚ˝ úÙÚÙBlazy, Kakvi, Kiltz, Pan (2015) 1.1 Tight Security The reductionist approach to cryptographic security algorithms seeks to prove theorems along the lines of: úÙÚ¸If a t-time adversary attacks the scheme with successful probability , then a t 0 -time algorithm can be constructed to break some computational problem with success probability  0 = /úÙß∏ and t 0 = k Å∑ t + o(t).úÙÚ˝. The parameters úÙß∏ úÙ˘• 1 and k úÙ˘• 1, or more simply the product k Å∑ úÙß∏, measures how tightly the security of the cryptographic scheme is related to the hardness of the underlying computational problem. Alternatively, when k úÙ¯Ë 1 as is the case in many reductions, úÙß∏ measures the security loss of the security reduction of our cryptographic scheme from the underlying assumption. A cryptographic scheme is tightly secure if úÙß∏ is a small constant that in particular does not depend on parameters under the adversaryúÙÚ˘s control, such as the adversaryúÙÚ˘s own success probability , the number of queries it chooses to make, and even the schemeúÙÚ˘s security parameter. The reduction phrases úÙÚ¸almost tight securityúÙÚ˝ from the literature refers to the case where úÙß∏ only depends on a small polynomial of the security parameter. Tight reduction is an elegant notion from a theoretical point of view. A tight reductionist proof (with respect to a well-defined security model) indicates that the security of a cryptographic scheme is (extremely) closely related to the hardness of the underlying hard problem, which is the optimal case we expect from provable security theory. On the other hand, it is also a determinant factor to the practicality of real-world security. Its opposite, loose security, means that in order to realise a desired úÙÚ¸realúÙÚ˝ target security level, one has to increase the úÙÚ¸apparentúÙÚ˝ security level inside the construction to compensate for the loose reduction. This inflates the size of data atoms by some polynomial, with in turn increases the running time of cryptographic operations by another polynomial, combining multiplicatively. 1.2 Identity-Based Encryption with Tight Security Digital signatures and identity-based encryption (IBE) are closely connected, which suggests that techniques that improve upon the security of signatures might also improve upon the security of IBE. In this work, we also investigate the problem of constructing tightly secure IBE from standard assumptions (without random oracles). In an IBE system, any random string that uniquely represents a userúÙÚ˘s identity, such as email address or driver license number, can act as a public key (within a certain domain or realm). Encryption uses this identity, together with some common domain-specific public parameters, to encrypt messages. Users are issued private decryption keys corresponding to their public identities, by a trusted authority (or distributed authorities) called Private Key Generator (PKG) which hold(s) (shares of) the master secret key for a domain. Decryption succeeds if the identity associated with the ciphertext matches the identity associated with the private key, in the same domain. The strongest, most natural and most widely accepted notion of security for IBE is the adaptive security model or full security model, formally defined in [18]. In this model, the adversary is able to announce its target (the challenge identity it wants to attack) at any time during the course of its adaptive interaction with the system. Without the luxury of random 2 oracles, an easier security model to achieve was the selective security model, where the adversary must announce its target identity at the onset of its interaction with the system. In the last fifteen years, a great many IBE schemes have been proposed, with varying efficiency, security models, hardness assumptions, and other features. In the standard model (i.e., without random oracles or other idealised oracles), we mention several notable IBE schemes which have been constructed from bilinear maps in the selective model [27, 14] and the adaptive model [15, 56, 35, 57, 29, 12], and from lattices in the adaptive model [2, 28, 5]. It is fair to say that, by now, the art of selectively secure IBE has been well honed. However, adaptively secure IBE schemes from standard assumptions with tight security (in the sense that the security loss is a small constant) remain unknown. The best known adaptively secure IBE schemes in terms of tight reduction are based on linear assumptions over pairings and achieve almost tight security (e.g., [29, 12, 6, 44]). Waters [56] states this open problem as follows: Open Problem #2úÙÚÙTight Adaptively Secure IBE úÙÚ¸Construct a tightly, adaptively secure IBE scheme from standard computational hardness assumptions without random oracles.úÙÚ˝ úÙÚÙWaters (2005) Furthermore, for all known directly constructed adaptively secure IBE scheme from standard post-quantum assumption (specifically the LWE assumption), i.e. [2, 28, 5], their security loss during reduction depends on the number adversaryúÙÚ˘s of queries. That is there is current no even úÙÚ¸almost tightlyúÙÚ˝ secure adaptive IBE scheme based on standard computational problems which are conjectured to be hard under quantum attacks. The following problem is still open. Open Problem #3úÙÚÙúÙÚ¸AlmostúÙÚ˝ Tight Adaptively Secure, Post-Quantum IBE úÙÚ¸Construct an úÙÚ¸almostúÙÚ˝ tightly, adaptively secure IBE scheme from standard postquantum assumptions without random oracles.úÙÚ˝ 1.3 Our Results Our work uses pseudorandom functions (PRFs). Recall a PRF is a (deterministic) function: PRF : K Å◊ D úÙˆÚ R with the following security property. For random secret key K $úÙˆúÙ¯≤ K, PRF(K, Å∑) is computationally indistinguishable from a random function úÙıÊ : D úÙˆÚ R, given oracle access to either PRF(K, Å∑) or úÙıÊ(Å∑). PRFs can be constructed from general assumptions (e.g., the existence of pseudo-random number generators [39]), number-theoretic assumptions (e.g., the DDH/k-LIN assumption [53, 31, 47]), and lattice assumption LWE [9, 8]. Our contribution is a construction of a class of adaptively secure short signature schemes/IBE schemes in the standard model. The schemesúÙÚ˘ security is tightly related to SIS/LWE and the security of an instantiated PRF PRF in the sense that the security loss is a nearly optimal constant factor. More precisely, let  and  0 be the advantage of an adversary in attacking our signature and IBE schemes respectively, SIS and LWE be the security level of the SIS and LWE assumptions on which our schemes are based, and PRF is the security level of the PRF instantiation PRF. Our constructions provide the following:  úÙ¯Ë 2(SIS + PRF),  0 úÙ¯Ë 2(LWE + PRF), and the (polynomial) runtime of reduction is approximately the same as attackerúÙÚ˘s runtime. Note that, depending on the underlying hardness assumption and the reduction of PRF, underlying assumptions and tightness of our signature/IBE scheme vary. By instantiating existing lattice-based/number theoretic-based PRFs, we obtain the following improvements upon known results: úÙÛ¢ By instantiating the úÙÚ¸almostúÙÚ˝ tightly secure PRFs from [9, 8] which are based on LWE assumption with super-polynomial modulus, we obtain the first úÙÚ¸almostúÙÚ˝ tightly secure short signature/IBE schemes from LWE with super-polynomial modulus whose security does not depend on the number of adversarial queries. Previously, the known lattice signature schemes either enjoy short signatures but loose reduction (such as [21, 51, 32]) 3 or have tight reduction but signatures consisting of a rather large number of lattice points ([11]), and the known adaptively secure lattice-based IBE schemes ([2, 5]) have loose reductions. This, at the first time, eliminates the dependency between the number of adversaryúÙÚ˘s queries and the security of lattice-based short signature scheme/IBE scheme. úÙÛ¢ If we relex the requirement of quantum resistance, by instantiating the (black-box) tightly secure PRFs based on DDH or k-LIN, whose security loss is only O(log2 úÙßª) for security parameter úÙßª, due to Jager [47], we obtain the IBE scheme with tightest security reduction so far: a factor of O(log2 úÙßª). Previous IBE schemes with almost tight security [29, 12] have a factor of O(úÙßª) of security loss. This improvement brings us closer again to answering the Open Problem #1 and #2. Meanwhile, an interesting and independent contribution of our work is that it indicates that tightly secure PRFs, which are efficiently computable by Boolean circuits, from standard computational assumptions are sufficient for us to build tightly, adaptively secure lattice signature/IBE from SIS/LWE assumption. Finally, we note that many existing provably secure PRF constructions, for instance the DDH-based constructions from [53, 31, 47] and lattice-based constructions from [9, 8], are efficient and can be computed by Boolean circuits in NC1 class. Instantiating a PRF circuits from these candidates in our construction results in polynomial SIS/LWE modulus in our construction (not the modulus for LWE-based PRFs). On the other hand, however, the (direct) lattice-based PRFs from [9, 8] assume LWE assumption with super-polynomial modulus, which makes our schemes rely on LWE assumption for super-polynomial modulus. How to construct efficient and low-depth PRFs from LWE with polynomial modulus remains an interesting open question. Table 1 provides a comparison between our signature scheme with a LWE-based PRF instantiation (from [9]) and a representative sample of the prominent lattice-based (quantum-safe) signature schemes from the literature. Note, Katz and Wang did not propose a SIS-based signature scheme in [48]. The scheme we refer to is a straightforward application of Katz-WangúÙÚ˘s proof technique to GPVúÙÚ˘08 signature scheme. Table 2 provides a comparison between our signature scheme with DDH-based PRF instantiation from [47], which only looses a factor O(log2 úÙßª) in security proof, and the representative signature schemes from traditional number-theoretic assumptions, including (strong) RSA, Dlog and linear assumptions over pairings. All of those assumptions are not conjectured to be quantum-safe. In each case, the two tables refer to conjectured quantum safe and quantum-unsafe constructions respectively. Table 3 gives a comparison between our IBE scheme (with both direct LWE-based PRF instantiation from [9] and DDH-based instantiation from [47]) and a representative selection of existing IBE schemes from the literature. It needs to mention that the bit length of PRF secret key determines the number of public matrices in our constructions. In the SIS-based signature scheme from [21] and LWE-based IBE schemes from [2, 28], the number of public matrices are determined by the bit length of messages and identities respectively. For the provably secure PRFs, the bit length of secret key is usually significantly larger than the bit length of messages and identities needed in [21, 2, 28]. So our constructions have larger concrete size of verification key than the signature scheme in [21] and larger concrete size of public parameters than the IBE schemes in [2, 28]. Efficiency Consideration. Though we focus on tightness of reduction in the context of short signature and IBE, we do not hide the inefficiency of our schemes, particularly with comparison to the adptively secure lattice-based signature/IBE scheme obained from the úÙÚ¸complexity leveragingúÙÚ˝ [14] of efficient selectively secure lattice-based signature/IBE scheme such as [2]. Although complexity leveraing is not very satisfactory from a theoretical perspective, it indeed often leads to the most practical secure cryptographic schemes. In the context of IBE, we have seen that the adaptively secure IBE scheme levearaged from selective DBDH-based IBE scheme 4 Table 1: Comparison between signature schemes from quantum-safe (Ring-)SIS assumption Scheme Signature size Security loss Assumption(s) Standard model? KWúÙÚ˘03 [48] O(1) Å◊ Z m O(1) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 3/2 ) ROM GPVúÙÚ˘08 [36] O(1) Å◊ Z m O(qhash) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 3/2 ) ROM BoyenúÙÚ˘10 [21] O(1) Å◊ Z m O(úÙßªqs) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 7/2 ) úÚ•‘ LyuúÙÚ˘12 [50] O(1) Å◊ Z m O(úÙßªqs) SIS, úÙıÊ( úÙ§¸ n 3/2 ) ROM MPúÙÚ˘12 [51] O(1) Å◊ Z m O(úÙßªqs) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 5/2 ) úÚ•‘ BHJKSSúÙÚ˘13 [13] O(log úÙßª) Å◊ Z m O(úÙßªqs) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 5/2 ) úÚ•‘ DMúÙÚ˘14 [32] O(1) Å◊ RO(log q) q O(úÙßªqs) Ring-SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 7/2 ) úÚ•‘ BKKPúÙÚ˘15 [11] O(úÙßª) Å◊ Z m O(1) SIS, úÙß≤ = úÙıÊ( úÙ§¸ n 3/2 ) úÚ•‘ AlperinúÙÚ˘15 [4] O(1) Å◊ Z m O(úÙßªqs) SIS, úÙß≤ = úÙıÊ( úÙ§¸ úÙß¥ 2úÙß¥ Å∑ n 11/2 ) úÚ•‘ Ours O(1) Å◊ Z m O(úÙßª) SIS+LWE? , úÙß≤ = úÙıÊ( úÙ§¸ ` 4c Å∑ n 7/2 ) úÚ•‘ úÙßª is the security parameter, n is the lattice hardness parameter, m is the lattice dimension, and úÙß≤ is the SIS parameter. qhash is the number of random-oracle queries (if applicable). qs is the number of signing queries. For DMúÙÚ˘14, the ring R = Zq[X]/(f(X)) for some cyclotomic polynomial f of degree n and q úÙ˘• úÙß≤ úÙ¯∫ núÙß…( úÙ¯∫ log n). For AlperinúÙÚ˘15, úÙß¥ satisfies 2q 2 s/ < 2 bc 0úÙß¥c for attackerúÙÚ˘s success probability  and arbitrary constant c 0 > 1. Our construction here consider instantiation of the direct LWE-based PRF from [9] which has security loss O(úÙßª) and can be computed by a NC1 circuit with input length ` and depth c log ` for some constant c > 1. ? The security of direct LWE-based PRF construction from [9] relies on LWE assumption with super-polynomial modulus. So LWE here refers to LWE assumption with super-polynomial modulus. in [14] has higher real-world efficiency than the adaptively secure Waters IBE scheme [56] (as well as the subsequent adaptive IBE schemes from similar standard pairing assumptions without random oracles) for the same security level. This may seem counter-intuitive, but to design adaptively secure IBE schemes one needs to carefully embed some specially crafted complex structures into the scheme, to provide enough freedom for the security reduction. This makes directly constructed adaptive IBE schemes rather bulky. Therefore, our current results are of more theoretic value. One the other hand, directly constructing adaptively secure schemes from standard assumptions usually requires new proof ideas and techniques which advance the state-of art and lead to further applications. Trying to get tighter reduction for the directly constructed adaptively secure schemes should be always welcome as it remains a very promising way of bridging the efficiency gap. 1.4 Overview of Our Approach Construction Outline. Our constructions use a PRF PRF : {0, 1} k Å◊ {0, 1} t úÙˆÚ {0, 1} which takes as input a truly random secret key from {0, 1} k and a string from {0, 1} t , and deterministically outputs a bit which is computationally indistinguishable from a random bit. In our signature scheme, apart from the úÙÚ¸leftúÙÚ˝ matrix A typical of all SIS/LWE based constructions, we set another 4 + k random matrices from Z nÅ◊m q , comprising: two úÙÚ¸signature subspace selectionúÙÚ˝ matrices A0, A1, k úÙÚ¸PRF secret keyúÙÚ˝ matrices {Bi}iúÙ¯®[k] , and two úÙÚ¸message representationúÙÚ˝ matrices C0, C1. The key generation algorithm further expresses PRF as a NAND Boolean circuit, which serves as a part of the public parameters or perhaps a common reference string. The signing key is a úÙÚ¸shortúÙÚ˝ basis TAof A and a PRF key K $úÙˆúÙ¯≤ {0, 1} k for PRF. The signer takes three steps to generate the signature of message M = x1x2 . . . xt úÙ¯® {0, 1} t . 5 Table 2: Comparison between signature schemes from various quantum-unsafe assumptions Scheme Sig. size Sec. loss Assumption(s) Standard model? GHRúÙÚ˘99 [34] O(1) Å◊ ZN O(1) Strong-RSA + D-I Hash úÚ•‘ BLSúÙÚ˘01 [20] O(1) Å◊ G O(úÙßªqs) CDH ROM KWúÙÚ˘03 [48] O(1) Å◊ |D| O(1) CFP ROM BBúÙÚ˘04 [16] O(1) Å◊ G O(1) qs-SDH úÚ•‘ WatersúÙÚ˘05 [56] O(1) Å◊ G O(úÙßªqs) CDH úÚ•‘ HWúÙÚ˘09 [46] O(1) Å◊ ZN O(úÙßªqs) RSA úÚ•‘ BHJKSSúÙÚ˘13 [13] O(1) Å◊ G O(úÙßªqs) DLog úÚ•‘ BHJKSSúÙÚ˘13 [13] O(1) Å◊ ZN O(úÙßªqs) RSA úÚ•‘ ADKMOúÙÚ˘13 [1] O(úÙßª) Å◊ G O(1) DLIN úÚ•‘ CWúÙÚ˘13 [29] O(k) Å◊ G O(úÙßª) k-LIN úÚ•‘ BKPúÙÚ˘14 [12] O(k) Å◊ G O(úÙßª) k-LIN úÚ•‘ BKKPúÙÚ˘15 [11] O(úÙßª) Å◊ G O(1) DLog úÚ•‘ BKKPúÙÚ˘15 [11] O(úÙßª) Å◊ ZN O(1) RSA,FAC úÚ•‘ Ours O(1) Å◊ Z m O(log2 úÙßª) SIS+DDH, úÙß≤ = úÙıÊ( úÙ§¸ ` 4c Å∑ n 7/2 ) úÚ•‘ úÙßª is the security parameter, n is the lattice hardness parameter, m is the lattice dimension, qs the number of signing queries, N is the RSA modulus, m is the lattice dimension, úÙß≤ is the SIS parameter, and k is a non-adversary-query-dependent parameter of the LIN assumption. For GHRúÙÚ˘99, D-I hash stands for division-intractable hash. For KWúÙÚ˘03, |D| the domain size of the instantiated claw-free permutation, which is abbreviated as CFP. Our construction here consider instantiating the DDH-based PRF from [47] which has security loss O(log2 úÙßª) and can be computed by a NC1 circuit with input length ` and depth c log ` for some constant c > 1. Firstly, it uses the key-homomorphic evaluation algorithm developed from [37, 19, 24] 1 to compute the unique matrix APRF,M from the circuit of PRF and the k+t matrices {Bi}iúÙ¯®[k] , Cx1 , Cx2 , . . . , Cxt . 2 Then it computes b = PRF(K, M) and sets the matrix FM,1úÙ¯≤b = [A | A1úÙ¯≤b úÙ¯≤ APRF,M] úÙ¯® Z nÅ◊2m q . Finally, it applies the trapdoor TA to generate the signature: a low-norm non-zero vector dM úÙ¯® Z 2m such that FM,1úÙ¯≤b Å∑dM = 0 (mod q). The verification algorithm checks whether the signature is a non-zero vector in Z 2m and has low-norm, and whether FM,b Å∑dM = 0 (mod q) or FM,1úÙ¯≤b Å∑ dM = 0 (mod q). If all these conditions are satisfied, the signature is accepted. Our IBE scheme works as follows. The public parameters contain matrices A, A0, A1, {Bi}iúÙ¯®[k] , C0, C1, a secure PRF PRF represented as a NAND Boolean circuit, and a random vector u úÙ¯® Z n q which is used to hide messages. The trapdoor basis TA and a secret PRF key K $úÙˆúÙ¯≤ {0, 1} k serve as master secret key. In private key generation for identity id = x1x2 . . . xt úÙ¯® {0, 1} t , the key-homomorphic evaluation algorithm is invoked to compute the unique matrix APRF,id from the circuit of PRF and the k + t matrices {Bi}iúÙ¯®[k] , Cx1 , Cx2 , . . . , Cxt . It then sets the úÙÚ¸functionúÙÚ˝ matrix to Fid,1úÙ¯≤b = [A | A1úÙ¯≤b úÙ¯≤ APRF,id] úÙ¯® Z nÅ◊2m q for b = PRF(K, M), and uses TA to sample a Gaussian vector did úÙ¯® Z 2m as private identity key where Fid,1úÙ¯≤b Å∑ did = u (mod q). To encrypt a message Msg úÙ¯® {0, 1} with an identity id, the encryptor computes APRF,id and sets two úÙÚ¸functionúÙÚ˝ matrices Fid,b = [A | Ab úÙ¯≤ APRF,id] and Fid,1úÙ¯≤b = [A | A1úÙ¯≤b úÙ¯≤ APRF,id]. It 1We will particularly use the evaluation algorithm due to Brakerski and Vaikuntanathan [24] for optimizing the SIS/LWE modulus. 2 It can be shown that for different massages M0 6= M2 APRF,M0 6= APRF,M1 with all but negligible probability. See section 3.3 for details. 6 Table 3: Comparison between adaptively secure IBE schemes from various assumptions Scheme Security loss Assumption Standard model? Quantum-safe BFúÙÚ˘01 [18] O(qid) BDH ROM úÚ•◊ KWúÙÚ˘03 [48] O(1) BDH ROM úÚ•◊ BBúÙÚ˘04a [14] O(2úÙßª ) DBDH, qid-BDHI úÚ•‘ úÚ•◊ BBúÙÚ˘04b [15] O(úÙßªqid) DBDH úÚ•‘ úÚ•◊ WatersúÙÚ˘05 [56] O(úÙßªqid) DBDH úÚ•‘ úÚ•◊ GentryúÙÚ˘06 [35] O(1) qid-ABDHE úÚ•‘ úÚ•◊ GPVúÙÚ˘08 [36] O(qhash) LWE ROM úÚ•‘ WatersúÙÚ˘09 [57] O(qid) DBDH úÚ•‘ úÚ•◊ ABBúÙÚ˘10 [2] O(úÙßªqid) LWE úÚ•‘ úÚ•‘ CHKPúÙÚ˘12[28] O(úÙßªqid) LWE úÚ•‘ úÚ•‘ LWúÙÚ˘12 [49] O(q) DLIN úÚ•‘ úÚ•◊ CWúÙÚ˘13 [29] O(úÙßª) k-LIN úÚ•‘ úÚ•◊ BKPúÙÚ˘14 [12] O(úÙßª) k-LIN úÚ•‘ úÚ•◊ Ours O(úÙßª) LWE ? úÚ•‘ úÚ•‘ O(log2 (úÙßª)) DDHúÙÛ†+LWE úÚ•‘ úÚ•◊ úÙßª is the security level, qid the number of private key queries and qhash the number of random-oracle queries (if applicable). ? Here we instantiate the PRF by direct LWE-based PRF construction from [9] which has O(úÙßª) security loss and relies on LWE assumption with super-polynomial modulus. So the LWE here refers to LWE assumption with super-polynomial modulus. The schemes ABBúÙÚ˘10 and CHKPúÙÚ˘12 assume LWE assumption polynomial modulus. úÙÛ† Here we instantiate the PRF by DDH-based PRF construction from [47] which has (black-box) security loss O(log2 (úÙßª)). generates two independent GPV-style ciphertexts [36]. The first one uses Fid,b: úÛ‚— úÛ‚“ úÛ‚” cb,0 = s > b u + úÙßΩb,0 + Msg Å∑ bq/2c c > b,1 = s > b Fid,b + úÙßΩ > b,1 and the second is based on Fid,1úÙ¯≤b: úÛ‚— úÛ‚“ úÛ‚” c1úÙ¯≤b,0 = s > 1úÙ¯≤bu + úÙßΩ1úÙ¯≤b,0 + Msg Å∑ bq/2c c > 1úÙ¯≤b,1 = s > 1úÙ¯≤bFid,1úÙ¯≤b + úÙßΩ > 1úÙ¯≤b,1 for random vectors sb, s1úÙ¯≤b $ úÙˆúÙ¯≤ Z n q , two small noise scalars úÙßΩb,0, úÙßΩ1úÙ¯≤b,0, and two low-norm noise vectors úÙßΩb,1, úÙßΩ1úÙ¯≤b,1. The decryption algorithm uses did to try both ciphertexts; one of them should work. Here as a technical caveat, we need some redundant information in the messages in order to check whether a recovered message is well-formed. To this end, one option is to apply the standard way of encrypting multiple bits in GPV-style ciphertexts without affecting the security analysis. That is, instead of using just a vector u úÙ¯® Z n q in the public key, we use a matrix U úÙ¯® Z nÅ◊z q allowing us to encrypt z bits. A second option, which costs nothing if hybrid encryption is being used, is to use multi-bit GPV-style encryption to encrypt a symmetric session key without redundancy, again using a matrix Z nÅ◊z q and rely on downstream symmetric integrity checks or MACs to weed out the incorrect ciphertexts. Proof Outline. The security reduction of our signature scheme uses an efficient adversary to solve a of SIS problem instance A úÙ¯® Z nÅ◊m q : a short non-zero vector e úÙ¯® Z m such that 7 Ae = 0 (mod q). The reduction embeds a randomly picked secret key K for PRF in verification key. More specifically, the reduction selects low-norm matrices RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 $úÙˆúÙ¯≤ {1, úÙ¯≤1} mÅ◊m, a PRF secret key K = s1s2 . . . sk $úÙˆúÙ¯≤ {0, 1} k and sets A0 = ARA0 , A1 = ARA1 + G, {Bi = ARBi + siG}iúÙ¯®[k] , C0 = ARC0 and C1 = ARC1 + G. Here, K is completely hidden from adversaryúÙÚ˘s view. For answering a signing query on message M, the reduction computes APRF,M = AR + PRF(K, M)G for some known low-norm m Å◊ m matrix R that depends on RA0 , RA1 , {RBi }iúÙ¯®[k] , RC0 , RC1 , K and M. Let PRF(K, M) = b, the reduction sets FM,1úÙ¯≤b = [A | A1úÙ¯≤b úÙ¯≤ APRF,M] = [A | AR + (1 úÙ¯≤ 2b)G] and uses the trapdoor from G to compute the decryption key. Note, we use PRF to select the matrix Ab which is the same as the real scheme. For a valid forgery (MúÙ¯∑ , dMúÙ¯∑ ), since b = PRF(K, MúÙ¯∑ ) is unpredictable to the adversary, FMúÙ¯∑ ,b Å∑ dMúÙ¯∑ = 0 (mod q) happens with essentially probability 1/2 leading to a valid SIS solution. The security reduction for our IBE scheme is similar to the reduction of the signature scheme. Basically, the reduction answers key generation queries in the same way as answering signing queries in the signature scheme reduction. To construct the challenge ciphertext for a challenge identity idúÙ¯∑ , the LWE challenge is embedded in the function matrix FidúÙ¯∑ ,b = [A | AR] for which the simulator cannot produce private key. Another ciphertext based on FidúÙ¯∑ ,1úÙ¯≤b = [A | AR + (1 úÙ¯≤ 2b)G] is generated as in the real scheme. With essentially half probability, the adversary will choose the ciphertext under FidúÙ¯∑ ,b to attack giving out useful information for solving the LWE challenge. We refer to the full details in the rest of the paper. Related Works. In the related and concurrent work by Brakerski and Vaikuntanathan [25], a similar idea of embedding PRFs into encryption schemes has been used to construct the first semi-adaptively secure attribute-based encryption scheme from lattices supporting an a priori unbounded number of attributes. The recent work by Bai et al. [7] addresses the problem of improving efficiency of lattice-based cryptographic schemes via a different but novel way. Their proposal is about using RÅ¥enyi divergence instead of statistical distance in the context of lattice-based cryptography which leads to (sometimes simpler) security proofs for more efficient lattice-based schemes. 2 Preliminaries Notation. úÙÚ¯PPTúÙÚ˘ abbreviates úÙÚ¸probabilistic polynomial-timeúÙÚ˝. If S is a set, we denote by a $ úÙˆúÙ¯≤ S the uniform sampling of a random element of S. For a positive integer n, we denote by [n] the set of positive integers no greater than n. We use bold lowercase letters (e.g. a) to denote vectors and bold capital letters (e.g. A) to denote matrices. For a positive integer q úÙ˘• 2, let Zq be the ring of integers modulo q. We denote the group of nÅ◊m matrices in Zq by Z nÅ◊m q . Vectors are treated as column vectors. The transpose of a vector a (resp. a matrix A) is denoted by a > (resp. A>). For A úÙ¯® Z nÅ◊m q and B úÙ¯® Z nÅ◊m0 q , let [A|B] úÙ¯® Z nÅ◊(m+m0 ) q be the concatenation of A and B. We denote the Gram-Schmidt ordered orthogonalization of a matrix A úÙ¯® Z mÅ◊m by AúÙ§¸ . The inner product of two vectors x and y is written hx, yi. For a security parameter úÙßª, a function negl(úÙßª) is negligible in úÙßª if it is smaller than all polynomial fractions for a sufficiently large úÙßª. We recall the following generalisation of the left-over hash lemma. Lemma 2.1 ([2], Lemma 4). Suppose that m > (n+ 1) log q +úÙß…(log n) and that q > 2 is prime. Let R be an mÅ◊k matrix chosen uniformly in {1, úÙ¯≤1} mÅ◊k mod q where k = k(n) is polynomial in n. Let A and B be matrices chosen uniformly in Z nÅ◊m q and Z nÅ◊k q respectively. Then, for all vectors w úÙ¯® Z m q , the distribution (A, AR, R>w) is statistically close to the distribution (A, B, R>w). 8 For a vector u, we let kuk and kukúÙ¯æ denote its `2 norm and `úÙ¯æ norm, respectively. For a matrix R úÙ¯® Z kÅ◊m, we define two matrix norms: úÙÚÛ kRk denotes the `2 length of the longest column of R. úÙÚÛ kRk2 is the operator norm of R defined as kRk2 = supxúÙ¯®Rm+1 kR Å∑ xk. Lemma 2.2 ([2], Lemma 5). Let R be a random chosen matrix from {1, úÙ¯≤1} mÅ◊m, then Pr[kRk2 > 12úÙ¯∫ 2m] < eúÙ¯≤m. 2.1 Lattice Background 2.1.1 Lattice Definitions Definition 2.1. Let a basis B = [b1 | . . . |bm] úÙ¯® (R m) m of linearly independent vectors. The lattice generated by B is defined as úÙ¶˚ = {y úÙ¯® R m : úÙ¯£si úÙ¯® Z, y = Pm i=1 sibi}. The dual lattice úÙ¶˚ úÙ¯∑ of úÙ¶˚ is defined as úÙ¶˚úÙ¯∑ = {z úÙ¯® R m : úÙ¯†y úÙ¯® úÙ¶˚, hz, yi úÙ¯® Z}. Definition 2.2. For q prime, A úÙ¯® Z nÅ◊m q and u úÙ¯® Z n q , we define the m-dimensional (full-rank) random integer lattice úÙ¶˚úÙ˘Â q (A) = {e úÙ¯® Z m : Ae = 0 (mod q)}, and the úÙÚ¸shifted latticeúÙÚ˝ as the coset úÙ¶˚u q (A) = {e úÙ¯® Z m : Ae = u (mod q)}. 2.1.2 Trapdoors of Lattices and Discrete Gaussians It is shown in [3, 51] how to sample a úÙÚ¸nearlyúÙÚ˝ uniform random matrix A úÙ¯® Z nÅ◊m along with a trapdoor matrix TA úÙ¯® Z mÅ◊m which is a short or low-norm basis of the induced lattice úÙ¶˚úÙ˘Â q (A). We refer to this procedure as TrapGen. Lemma 2.3. There is a PPT algorithm TrapGen that takes as input integers n úÙ˘• 1, q úÙ˘• 2 and a sufficiently large m = O(n log q), outputs a matrix A úÙ¯® Z nÅ◊m q and a trapdoor matrix TA úÙ¯® Z mÅ◊m, such that A Å∑ TA = 0, the distribution of A is statistically close to the uniform distribution over Z nÅ◊m q and kTúÙ§¸ Ak = O( úÙ¯∫ n log q). Discrete Gaussians. Let m úÙ¯® Z>0 be a positive integer and úÙ¶˚ úÙ˘¬ Z m. For any real vector c úÙ¯® R m and positive parameter úÙß√ úÙ¯® R>0, let the Gaussian function úÙß¡úÙß√,c(x) = exp úÙ¯≤úÙß¿kx úÙ¯≤ ck 2/úÙß√2 
















